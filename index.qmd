---
echo: false
output: false
format:
  html:
    grid:
      sidebar-width: 0px
      body-width: 2000px
      margin-width: 0px
      gutter-width: 0.5rem
---

{{< include /page1/_labels.qmd >}}
{{< include /page1/_inputs.qmd >}}
{{< include /page1/_globals.qmd >}}
{{< include /page1/_leaflet_functions.qmd >}}


<!------------------------
First block: mode & lang
------------------------->

```{ojs}
//| output: true
//| label: head-page
html
`
<div class="container">
  <div class="mode-selector">${viewof mode}</div>
  <p>${switch_label}<div class="lang-selector">${viewof lang}</div></p>
<div/>
`
```

<!------------------------
Second block: filters or search
------------------------->


```{ojs}
//| label: input-selector-definition
selectors = {
  let selectors ;

  if (mode == "explorer"){
    selectors = html
    `
    <div class="container">
      <div class="select-container">
        <div>${viewof filter_choice}</div>
        <div>${widget_to_print}</div>
      </div>
    </div>
    `
    return selectors
  }

  selectors = html`<div>${viewof search}</div>`
  return selectors
}
```


```{ojs}
//| output: true
//| label: input-selector
html`${selectors}`
```

<!------------------------
Main block
- Left: leaflet map
- Right: ascent characteristics
------------------------->


```{ojs}
//| output: true
html`
<div class="main-container">
  <div id = "leafletmap" style="width: 40%;">${leafletmap}</div>
  <div class="column spacer" style="width: 2%;">
      <!-- Spacer column -->
  </div>
  <div style="width: 58%;">
    <div id="available-ascent">
    <div><i>Ascensions correspondant à la recherche</i></div>
    <br>
    ${table_selected}
    <br>
    </div>
  <div id="statsElement"><i>Pas d'ascension sélectionnée, cliquer sur la carte pour afficher le profil de l'ascension.</i></div>
  </div>
</div>
`
```



```{ojs}
printed_points = {
  let printed_points;
  if (mode === "explorer") {
      printed_points = geo.filter(sommets, (d) => filter_active_width(d, filter_choice));
  } else {
      const searchIds = search.map(s => s.id);
      printed_points = geo.filter(sommets, (d) => searchIds.includes(d.id));
  }
  return printed_points
}
```




```{ojs}
function rank_ascent(sommetsGeoJson, variableToPlot, selectedClimb, lang = "fr"){
 const namelabel = (lang == "fr") ? "Ascension" : "Ascent" 
 const gainlabel = (lang == "fr") ? "Dénivelé positif" : "Elevation gain" 
 const massiflabel = (lang == "fr") ? "Massif" : "Mountain side" 
 const percentlabel = (lang == "fr") ? "Pente moyenne" : "Average slope" 
 let p = Plot.plot({
  color: {
      type: "sequential",
      scheme: "Turbo"
    },
    marks: [
      Plot.ruleX(
        sommetsGeoJson.features.map(d=>d.properties),
        {
          x: variableToPlot, stroke: variableToPlot,
          channels: {
            nom: {label: namelabel, value: "nom"},
            deniv: {label: gainlabel, value: (d) => `${d.denivellation}m`},
            massif: {label: massiflabel, value: "massif"},
            percent: {value: (d) => `${d.percent_moyen}%`, label: percentlabel},
            },
          tip: {
            format: {
              stroke : false
            },
            anchor: "top"
          },
          strokeOpacity: 0.2}
      ),
      Plot.ruleX([selectedClimb], {x : variableToPlot, stroke: "red", strokeWidth: 2})
    ]
  })
  return p
}
```


```{ojs}
widget_to_print = {
  switch (filter_choice) {
    case filter_checkbox_length:
      console.log("Choosing filter by length")
      return Inputs.bind(
          Range([1, max_length], {unit: "km"}),
          viewof climb_length
      )
    case filter_checkbox_deniv:
      console.log("Choosing filter by height gain")
      return Inputs.bind(
        Range([1, max_denivelation], {unit: "m"}),
        viewof climb_height
      )
    case filter_checkbox_category:
      console.log("Choosing filter by category")
      return Inputs.bind(
        Inputs.checkbox(
          categories,
          {
            sort: "descending",
            value: ["HC", "Cat 1"],
            //label: category_label
          }
        ),
        viewof category
      )
    case filter_checkbox_slope:
      console.log("Choosing filter by average slope")
      return Inputs.bind(
        Range([0, max_slope], {unit: "%", step: 0.2}),
        viewof climb_slope
      )
    default:
      return false
  }
}

function filter_active_width(d, widget) {
  switch (widget) {
    case filter_checkbox_deniv:
      return d.denivellation > climb_height;
    case filter_checkbox_length:
      return d.longueur > climb_length;
    case filter_checkbox_category:
      return category.includes(d.category);
    case filter_checkbox_slope:
      return d.percent_moyen > climb_slope;
    default:
      return false; // or any default case handling you prefer
  }
}

```




```{ojs}
function getColorForCategory(category) {
  switch (category) {
    case 'Cat 1':
      return 'blue';
    case 'Cat 2':
      return 'green';
    case 'Cat 3':
      return 'yellow';
    case 'Cat 4':
      return 'orange';
    case 'HC':
      return 'red';
    default:
      return 'gray';
  }
}
```

```{ojs}
function tooltipSummit(feature){
  const tooltipMessage = `<b>${feature.properties.nom}</b><br><i>Cliquer sur ce sommet pour en savoir plus</i>`
  return tooltipMessage
}
```

```{ojs}
leafletmap = {

  // Create a container element for leaflet map
  let parent = DOM.element('div', { style: `width:${0.4*width}px;height:${0.85*screenHeight}px` });
  yield parent;
  var map = L.map(parent).setView([0, 0], 5);

  // Add the layer control to the map
  let baseLayers = availableLayers(L, map) ;
  L.control.layers(baseLayers).addTo(map);


    // Define a function that will be called for each feature in your GeoJSON layer
  function popEventSummit(feature, layer) {

      // Add mouseover event listener
      layer.on('mouseover', function() {
        const tooltipMessage = tooltipSummit(feature) ;
        layer.bindTooltip(tooltipMessage, {permanent: false, direction: "auto"}).openTooltip();
      });

      // Create popup for ascent summit
      layer.bindPopup(
        popUpSummit(feature, lang)
      );

     layer.on({
       click: whenClicked, //callback functions
     });
      
      // Existing event listener for popup opens
      layer.on('popupopen', function() {
        const statsElement = document.getElementById('statsElement');
        const availableAscents = document.getElementById('available-ascent');        
        
        // Update the content of 'statsElement' with the desired statistics from 'feature.properties'
        statsElement.innerHTML = container_ascent(feature, lang) ;
        availableAscents.innerHTML = "" ;


        // Fetch route for selected ascent
        const id = feature.properties.id;
        const polylineUrl = `https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/split/${id}.geojson`;

        // Create a polyline
        fetch(polylineUrl)
          .then(response => response.json())
          .then(data => ascentTrackPolyline(map, data, feature))
          .catch(error => console.error('Error loading the polyline GeoJSON:', error));
      });

  }
  
    var geojsonLayer = L.geoJson(printed_points, {
      onEachFeature: popEventSummit,
      pointToLayer: function(feature, coordinates) {
        return createIcon(feature, coordinates)        
      }
    }).addTo(map);
  
    geojsonLayer.setStyle({
      color: 'red',
      weight: 5
  });

  
    map.fitBounds(geojsonLayer.getBounds())
}
```


```{ojs}
function createIcon(feature, coordinates){
        const color_value = getColorForCategory(feature.properties.category);
        const iconUrl = `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color_value}.png`;
                
        var icon_color = new L.Icon({
          iconUrl: iconUrl,
          shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        });
        
        return L.marker(coordinates, {icon: icon_color})

}
```

```{ojs}
function ascentTrackPolyline(map, data, feature){
            // Create a polyline from the GeoJSON and add it to the map
            const polyline = L.geoJson(data, {
              color: 'red', // You can customize the polyline's style here
              weight: 3
            }).addTo(map);

            // Mouseover for ascent characteristics 
            polyline.on('mouseover', function() {
              this.bindTooltip(
                 tooltipRoute(feature),
                {permanent: false, direction: "top"}).openTooltip();
              
            });

            // Get mouse location on the map to interactively update a figure
            const points = toGeoJSONFeatureCollection(data);
            
            // polyline.on('mousemove', function(e) {
              // var nearest = get_nearest_point(e, points)
              // Update the mutable hover_alt to the altitude
              // mutable hover_alt = nearest;
            // });

  return polyline
}
```

```{ojs}
function get_nearest_point(e, points){
  // 'e.latlng' gives you the LatLng object of where the mouse currently is
  const mouseLatLng = e.latlng;
  const targetPoint = turf.point([mouseLatLng.lng, mouseLatLng.lat]);
  var nearest = turf.nearestPoint(targetPoint, points);
  return nearest
}
```

```{ojs}
// Function to convert array of coordinate arrays to a FeatureCollection
function toGeoJSONFeatureCollection(data) {
  const coordsArray = data.features.map(d => d.geometry.coordinates);
  // Map each coordinate array to a GeoJSON Point feature
  const features = coordsArray.flat().map(coords => ({
    "type": "Feature",
    "properties": {
      // If you have properties to include, add them here
      "altitude": coords[2]  // Example property
    },
    "geometry": {
      "type": "Point",
      "coordinates": [coords[0], coords[1]]  // Only longitude and latitude are used for Point
    }
  }));

  // Return as a FeatureCollection
  return {
    "type": "FeatureCollection",
    "features": features
  };
}
```



```{ojs}
{
  document.querySelector('#stats-denivellation').appendChild(
    rank_ascent(sommets, "denivellation", selectedClimb, lang)
  )
  document.querySelector('#stats-denivellation').appendChild(
    rank_ascent(sommets, "longueur", selectedClimb, lang)
  )

}
```





