[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "climb tracker üöµ",
    "section": "",
    "text": "raw = {\n  // URLs of the GeoJSON files\n  const geojsonUrl1 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/alpes-nord-sommets.geojson\";\n  const geojsonUrl2 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/alpes-sud-sommets.geojson\";\n  const geojsonUrl3 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/pyrenees.geojson\";\n  const geojsonUrl4 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/massif-central.geojson\";\n  const geojsonUrl5 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/vosges.geojson\";\n  const geojsonUrl6 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/autres-massifs.geojson\";\n  const geojsonUrl7 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/autres.geojson\";\n  const geojsonUrl8 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/missed.geojson\";\n\n  // Fetch\n  const fetchGeoJSON1 = fetch(geojsonUrl1).then(response =&gt; response.json());\n  const fetchGeoJSON2 = fetch(geojsonUrl2).then(response =&gt; response.json());\n  const fetchGeoJSON3 = fetch(geojsonUrl3).then(response =&gt; response.json());\n  const fetchGeoJSON4 = fetch(geojsonUrl4).then(response =&gt; response.json());\n  const fetchGeoJSON5 = fetch(geojsonUrl5).then(response =&gt; response.json());\n  const fetchGeoJSON6 = fetch(geojsonUrl6).then(response =&gt; response.json());\n  const fetchGeoJSON7 = fetch(geojsonUrl7).then(response =&gt; response.json());\n  const fetchGeoJSON8 = fetch(geojsonUrl8).then(response =&gt; response.json());\n\n  // When both GeoJSONs are fetched, combine them\n  let raw = Promise.all([\n    fetchGeoJSON1, fetchGeoJSON2,\n    fetchGeoJSON3, fetchGeoJSON4,\n    fetchGeoJSON5, fetchGeoJSON6,\n    fetchGeoJSON7, fetchGeoJSON8\n    ]).then(values =&gt; {\n    const combinedFeatures = [\n      ...values[0].features,\n      ...values[1].features,\n      ...values[2].features,\n      ...values[3].features,\n      ...values[4].features,\n      ...values[5].features,\n      ...values[6].features,\n      ...values[7].features\n      ]; // Combine features from both GeoJSON files\n\n    // Create a new GeoJSON object with combined features\n    const combinedGeoJSON = {\n      type: \"FeatureCollection\",\n      features: combinedFeatures\n    };\n\n    return combinedGeoJSON\n\n  }).catch(error =&gt; {\n    console.error(\"Error fetching or combining GeoJSONs:\", error);\n  });\n\n  return raw\n}\n\n\n\n\n\n\n\nsommets = geo.filter(raw, (d) =&gt; !d.vtt)\ncols = sommets.features.map(d=&gt;d.properties)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\navailableHeight = window.innerHeight\nscreenHeight = 0.9*(availableHeight - document.getElementById(\"quarto-header\").offsetHeight)\navailableWidth = window.innerWidth\nmapWidth = (width &gt; 400) ? 0.4*width : 0.95*width \nmapHeight = (width &gt; 400) ? 0.85*screenHeight : 0.5*screenHeight\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Range(range, options = {}) {\n  const [min, max] = range;\n  const {\n    className = \"Range\",\n    vertical = false,\n    label = null,\n    format = (x) =&gt; +x,\n    step = 1,\n    value = (min + max) / 2,\n    style = \"\",\n    labelStyle = \"\",\n    rangeStyle = \"\",\n    valueStyle = \"\",\n    unit = \"\" // New option for specifying a unit\n  } = options;\n  const rangeWrap = htl.html`&lt;div class=${className} style=\"${style}\"&gt;&lt;/div&gt;`;\n  Object.assign(rangeWrap.style, {\n    display: \"inline-flex\",\n    position: \"relative\",\n    userSelect: \"none\",\n    alignItems: \"center\",\n    gap: \"4px\"\n  });\n  const valueDisplay = htl.html`&lt;output style=\"${valueStyle}\"&gt;&lt;/output&gt;`;\n  Object.assign(valueDisplay.style, {\n    display: \"inline-block\"\n  });\n  const rangeInput = htl.html`&lt;input type=range min=${min} max=${max} step=${step} value=${value} style=${rangeStyle}&gt;&lt;/input&gt;`;\n  Object.assign(rangeInput.style, {\n    display: \"inline-block\"\n  });\n  if (vertical) {\n    rangeInput.setAttribute(\"orient\", \"vertical\");\n    rangeInput.style.writingMode = \"bt-lr\";\n    rangeInput.style[\"-webkit-appearance\"] = \"slider-vertical\";\n    rangeInput.style.width = \"8px\";\n  }\n\n  rangeWrap.append(rangeInput, valueDisplay);\n\n  if (label) {\n    const labelElement = htl.html`&lt;label style=${labelStyle}&gt;${label}&lt;/label&gt;`;\n    rangeWrap.prepend(labelElement);\n  }\n\n  rangeInput.oninput = () =&gt; {\n    // Append the unit to the formatted number\n    valueDisplay.textContent = `${format(rangeInput.valueAsNumber)}${unit}`;\n    rangeWrap.value = rangeWrap.valueAsNumber = rangeInput.valueAsNumber;\n    rangeWrap.dispatchEvent(new CustomEvent(\"input\"));\n  };\n\n  rangeInput.oninput(); // Initialize the displayed value\n  return rangeWrap;\n}\n\n\n\n\n\n\n\nstartStop = () =&gt; {\nconst buttons = html`\n&lt;form class=\"form-language-switcher\"&gt;\n  &lt;input value=\"üá´üá∑\" type=\"button\" name=\"stop\" id=\"button_french\" class=\"button_lang current_lang\"&gt;\n  &lt;input value=\"üá¨üáß üá∫üá∏\" type=\"button\" name=\"start\" id=\"button_english\" class=\"button_lang\"&gt;\n&lt;/form&gt;\n`\nbuttons.value = \"fr\"\n\n// French button  \nbuttons.stop.onclick = event =&gt; {\n  buttons.value = \"fr\";\n  event.preventDefault(); // Don‚Äôt submit the form.\n  buttons.dispatchEvent(new CustomEvent(\"input\"));                      \n  const french = document.getElementById(\"button_french\") ;\n  const english = document.getElementById(\"button_english\") ;\n  french.classList.add(\"current_lang\")\n  english.classList.remove(\"current_lang\")\n}\n// English button  \nbuttons.start.onclick = event =&gt; {\n  buttons.value = \"en\";\n  event.preventDefault(); // Don‚Äôt submit the form.\n  buttons.dispatchEvent(new CustomEvent(\"input\")); \n  const french = document.getElementById(\"button_french\") ;\n  const english = document.getElementById(\"button_english\") ;\n  english.classList.add(\"current_lang\")\n  french.classList.remove(\"current_lang\")\n}\n\nreturn buttons\n}\n\n\n\n\n\n\n\n\ncategory_label = html`&lt;span class=\"info-container\"&gt;\n  &lt;span style=\"color: orange\" class=\"infopicto\"&gt;${getIconSvg(\"info\")}\n    &lt;span class=\"tooltip-content\"&gt;\n      ${lang == 'fr' ? 'Version simplifi√©e de la classification UCI &lt;br&gt;D√©nivel√©:' : 'Simplified UCI classification&lt;br&gt;Gain:'}\n      ${classificationDetails}\n    &lt;/span&gt;\n  &lt;/span&gt;\n&lt;/span&gt;`\n\n\n\n\n\n\n\nclassificationDetails = `\n&lt;ul&gt;\n  &lt;li&gt;Cat 4: 80 - 159m&lt;/li&gt;\n  &lt;li&gt;Cat 3: 160 - 319m&lt;/li&gt;\n  &lt;li&gt;Cat 2: 320 - 639m&lt;/li&gt;\n  &lt;li&gt;Cat 1: 640 - 799m&lt;/li&gt;\n  &lt;li&gt;HC: 800m and more &lt;/li&gt;\n&lt;/ul&gt;\n`\n\n\n\n\n\n\n\n\nfunction slice(...options) {\n  return array =&gt; array.slice(...options);\n}\n\n\n\n\n\n\n\nfunction get_nearest_point(e, points){\n  // 'e.latlng' gives you the LatLng object of where the mouse currently is\n  const mouseLatLng = e.latlng;\n  const targetPoint = turf.point([mouseLatLng.lng, mouseLatLng.lat]);\n  var nearest = turf.nearestPoint(targetPoint, points);\n  return nearest\n}\n\n\n\n\n\n\n\n// Function to convert array of coordinate arrays to a FeatureCollection\nfunction toGeoJSONFeatureCollection(data) {\n  const coordsArray = data.features.map(d =&gt; d.geometry.coordinates);\n  // Map each coordinate array to a GeoJSON Point feature\n  const features = coordsArray.flat().map(coords =&gt; ({\n    \"type\": \"Feature\",\n    \"properties\": {\n      // If you have properties to include, add them here\n      \"altitude\": coords[2]  // Example property\n    },\n    \"geometry\": {\n      \"type\": \"Point\",\n      \"coordinates\": [coords[0], coords[1]]  // Only longitude and latitude are used for Point\n    }\n  }));\n\n  // Return as a FeatureCollection\n  return {\n    \"type\": \"FeatureCollection\",\n    \"features\": features\n  };\n}\n\n\n\n\n\n\n\nfunction normalize(gj) {\n    if (!gj || !gj.type) return null;\n    var types = {\n        Point: 'geometry',\n        MultiPoint: 'geometry',\n        LineString: 'geometry',\n        MultiLineString: 'geometry',\n        Polygon: 'geometry',\n        MultiPolygon: 'geometry',\n        GeometryCollection: 'geometry',\n        Feature: 'feature',\n        FeatureCollection: 'featurecollection'\n    };\n    var type = types[gj.type];\n    if (!type) return null;\n\n    if (type === 'geometry') {\n        return {\n            type: 'FeatureCollection',\n            features: [{\n                type: 'Feature',\n                properties: {},\n                geometry: gj\n            }]\n        };\n    } else if (type === 'feature') {\n        return {\n            type: 'FeatureCollection',\n            features: [gj]\n        };\n    } else if (type === 'featurecollection') {\n        return gj;\n    }\n}\n\n\n\n\n\n\n\nfunction fetchAndNormalizeGeoJSON(id, baseUrl) {\n    return fetch(`${baseUrl}/${id}.geojson`)\n        .then(response =&gt; response.json())\n        .then(normalize) // Assuming `normalize` function is available in the scope\n        .catch(error =&gt; {\n          console.error(`Failed to fetch or normalize GeoJSON for ID: ${id}`, error);\n          return null;\n        }) ;\n}\n\n\n\n\n\n\n\nfunction mergeGeoJSONs(ids, baseUrl) {\n    const promises = ids.map(id =&gt; fetchAndNormalizeGeoJSON(id, baseUrl));\n\n    return Promise.all(promises)\n        .then(normalizedGeoJSONs =&gt; {\n            return normalizedGeoJSONs.reduce((output, geojson) =&gt; {\n                if (geojson && geojson.features) {\n                    output.features.push(...geojson.features);\n                }\n                return output;\n            }, {\n                type: 'FeatureCollection',\n                features: []\n            });\n        });\n}\n\n\n\n\n\n\n\nasync function getCombinedGeoJSON(ids, baseUrl) {\n  try {\n    let combinedGeoJSON = await mergeGeoJSONs(ids, baseUrl);\n    console.log('Combined GeoJSON:', combinedGeoJSON);\n    // Handle the combined GeoJSON (e.g., display on map)\n    return combinedGeoJSON; // This will be a GeoJSON object\n  } catch (error) {\n    console.error('An error occurred while merging GeoJSONs:', error);\n    // Handle the error appropriately\n  }\n}\n\n\n\n\n\n\n\n\nimport {getIconSvg} from '@saneef/feather-icons'\n\n\n\n\n\n\n\nturf = require(\"@turf/turf@6\")\n\n\n\n\n\n\n\ngeo = require(\"geotoolbox@2\")\n\n\n\n\n\n\n\nPlot = require(\"https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.13/dist/plot.umd.min.js\")\n\n\n\n\n\n\n\nimport {multiAutoSelect} from \"@linogaliana/multi-auto-select\"\n\n\n\n\n\n\n\n\nfunction rank_ascent(sommetsGeoJson, variableToPlot, selectedClimb, lang = \"fr\"){\n const namelabel = (lang == \"fr\") ? \"Ascension\" : \"Ascent\" \n const gainlabel = (lang == \"fr\") ? \"D√©nivel√© positif\" : \"Elevation gain\" \n const massiflabel = (lang == \"fr\") ? \"Massif\" : \"Mountain side\" \n const percentlabel = (lang == \"fr\") ? \"Pente moyenne\" : \"Average slope\" \n let p = Plot.plot({\n  color: {\n      type: \"sequential\",\n      scheme: \"Turbo\"\n    },\n    marks: [\n      Plot.ruleX(\n        sommetsGeoJson.features.map(d=&gt;d.properties),\n        {\n          x: variableToPlot, stroke: variableToPlot,\n          channels: {\n            nom: {label: namelabel, value: \"nom\"},\n            deniv: {label: gainlabel, value: (d) =&gt; `${d.denivellation}m`},\n            massif: {label: massiflabel, value: \"massif\"},\n            percent: {value: (d) =&gt; `${d.percent_moyen}%`, label: percentlabel},\n            },\n          tip: {\n            format: {\n              stroke : false\n            },\n            anchor: \"top\"\n          },\n          strokeOpacity: 0.2}\n      ),\n      Plot.ruleX([selectedClimb], {x : variableToPlot, stroke: \"red\", strokeWidth: 2})\n    ]\n  })\n  return p\n}\n\n\n\n\n\n\n\n\nviewof lang = startStop()\n\n\n\n\n\n\n\nenglish = document.getElementById(\"button_english\")\nfrench = document.getElementById(\"button_french\")\n\nfunction change(lang_on, lang_off) {\n  if (!lang_on.classList.contains(\"current_lang\")) {\n    // if the span that the user clicks on does not have the \"current_lang\" class\n    lang_on.classList.add(\"current_lang\");\n    // add the \"current_lang\" class to it\n    lang_off.classList.remove(\"current_lang\");\n    // remove the \"current_lang\" class from the other span\n  }\n}\n\nenglish.addEventListener(\"click\", function() {\n    change(english, french);\n  }, false\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrench.addEventListener(\"click\", function() {\n    change(french, english);\n  }, false\n);\n\n\n\n\n\n\n\n\n\nlabel_click_map = (lang == \"fr\") ? \"Cliquer sur ce sommet pour en savoir plus\" : \"Click to learn more on that ascent\"\n\n\n\n\n\n\n\nno_ascent_label = (lang == \"fr\") ? \"Pas d'ascension s√©lectionn√©e, cliquer sur la carte pour afficher le profil de l'ascension.\" : \"No selected ascent, click on the map to see ascent details.\"\n\n\n\n\n\n\n\nfinding_ascent_label = (lang == \"fr\") ? \"Ascensions correspondant √† la recherche.\" : \"Ascent corresponding to search criterium.\"\n\n\n\n\n\n\n\nlabel_search_massif = (lang == \"fr\") ?\n  \"Choisir des massifs √† afficher\" : \n  \"Choose climbing regions\"\n\n\n\n\n\n\n\nheader_table_name = (lang == \"fr\") ? \"Ascension\" : \"Ascent\"\nheader_table_departure = (lang == \"fr\") ? \"D√©part\" : \"Start\"\nheader_table_alt = (lang == \"fr\") ? \"Altitude d'arriv√©e\" : \"Arrival height\"\nheader_table_avgpercent = (lang == \"fr\") ? \"Pente moyenne (%)\" : \"Average slope (%)\"\nheader_table_maxpercent = (lang == \"fr\") ? \"Pente maximale (%)\" : \"Maximum slope (%)\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsearch_label_choice = (lang == \"fr\") ? \"Rechercher une ascension\" : \"Finding an ascent\"\nexplorer_label_choice = (lang == \"fr\") ? \"Laissez moi explorer !\" : \"Let me explore !\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nswitch_label =  (lang == \"fr\") ? \"Switch to English version üá¨üáß üá∫üá∏\" : \"Passer √† la version fran√ßaise üá´üá∑\"\n\n\n\n\n\n\n\nmessage_category = lang == 'fr' ? `Version simplifi√©e de la classification UCI ${classificationDetails}` : `Simplified UCI classification ${classificationDetails}`\n\n\n\n\n\n\n\n\nfilter_checkbox_deniv = (lang == \"fr\") ? \"D√©nivel√©\" : \"Height gain\"\nfilter_checkbox_category = (lang == \"fr\") ? \"Cat√©gorie de l'ascension\" : \"Ascent category\"\nfilter_checkbox_length = (lang == \"fr\") ? `Longueur de l'ascension` : \"Ascension length\"\nfilter_checkbox_slope = (lang == \"fr\") ? \"Pente moyenne\" : \"Average slope\"\nfilter_multiselect_group = (lang == \"fr\") ? \"Massif de l'ascension\" : \"Mountain chain\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlabel_search_widget = (lang == \"fr\") ? \"Rechercher un col\" : \"Finding an ascent\"\n\n\n\n\n\n\n\n\nlabel_find_adress = (lang == \"fr\") ?\n  \"1Ô∏è‚É£ Taper une adresse ou une localisation dans la barre de recherche üëáÔ∏è\" :\n  \"1Ô∏è‚É£ Search for a location below üëáÔ∏è\"\n\n\n\n\n\n\n\nhtml\n`\n&lt;div class=\"lang-selector\"&gt;${viewof lang}&lt;/div&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n`\n\n\n\n\n\n\n\ncontainer_about(width)\n\n\n\n\n\n\n\ncontainer_about = function(width){\n    if (width&lt;600){\n        const small_container = html`\n            &lt;div style=\"justify-content: center; align-items: center; width: 100%;\"&gt;\n            &lt;div id=\"profile-picture\"&gt;\n                &lt;img src=\"https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/catbike.png\" \n                    alt=\"Cat on a bike\" \n                    style=\"max-width: 100%; height: auto; border-radius: 50%;\"&gt;\n            &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;br&gt;\n            &lt;div id=\"text-about\" style=\"width: 100%;\"&gt;${text_about}&lt;/div&gt;\n            &lt;br&gt;\n        ` ;\n        return small_container\n    }\n\n    if (width &lt; 1000){\n        const middle_container = html`\n        &lt;div class=\"main-container\" style=\"display: flex; flex-direction: row; justify-content: space-between;\"&gt;\n            &lt;div id=\"text-about\" style=\"width: 40%;\"&gt;${text_about}&lt;/div&gt;\n            &lt;div class=\"column spacer\" style=\"width: 10%;\"&gt;&lt;/div&gt; &lt;!-- Spacer column --&gt;\n            &lt;div style=\"width: 50%;\"&gt;\n            &lt;div id=\"profile-picture\"&gt;\n                &lt;img src=\"https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/catbike.png\" \n                    alt=\"Cat on a bike\" \n                    style=\"max-width: 100%; height: auto; border-radius: 50%;\"&gt;\n            &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        ` ;\n        return middle_container\n    }\n\n    const container_about = html`\n    &lt;div class=\"main-container\" style=\"display: flex; flex-direction: row; justify-content: space-between;\"&gt;\n        &lt;div class=\"column spacer\" style=\"width: 20%;\"&gt;&lt;/div&gt; &lt;!-- Spacer column --&gt;\n        &lt;div id=\"text-about\" style=\"width: 40%;\"&gt;${text_about}&lt;/div&gt;\n        &lt;div class=\"column spacer\" style=\"width: 2%;\"&gt;&lt;/div&gt; &lt;!-- Spacer column --&gt;\n        &lt;div style=\"width: 18%;\"&gt;\n        &lt;div id=\"profile-picture\"&gt;\n            &lt;img src=\"https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/catbike.png\" \n                alt=\"Cat on a bike\" \n                style=\"max-width: 100%; height: auto; border-radius: 50%;\"&gt;\n        &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"column spacer\" style=\"width: 20%;\"&gt;&lt;/div&gt; &lt;!-- Spacer column --&gt;\n    &lt;/div&gt;\n    ` ;\n    return container_about\n \n}\n\n\n\n\n\n\n\ntext_about = (lang == \"fr\") ? text_french : text_english\n\n\n\n\n\n\n\ntext_french = md`\n\nVoulant planifier le\npoint de chute id√©al pour faire quelques\nascensions cet √©t√© et curieux de d√©couvrir les\ncaract√©ristiques de nombreux\ncols disponibles en France, j'ai commenc√© √† construire\nce site √† mes heures perdues. \n\nCelui-ci simplifie\nl'exploration des cols cyclistes disponibles en France\nr√©f√©renc√©s sur [cols-cyclisme.com/](https://www.cols-cyclisme.com/). \nDes statistiques sur pr√®s de 2500 ascensions sont r√©pertori√©es ici.\n\nL'objectif du site est d'explorer librement les ascensions cyclistes\nfran√ßaises. Celles-ci peuvent √™tre choisies en fonction\nde crit√®res de difficult√©s (longueur, d√©nivel√©, etc.) ou \nbien peuvent √™tre s√©lectionn√©es dans le rayon d'un\npoint de d√©part. \n\nLe site s'enrichira prochainement de nouvelles pages, notamment\nde nombreuses statistiques construites √† partir de\ndonn√©es sur les ascensions cyclistes. \n`\n\n\n\n\n\n\n\ntext_english = md`\nWanting to plan the perfect spot for a few climbs this summer,\nand curious to discover the characteristics of the many passes available in France,\nI started building this site in my spare time. \n\nIt simplifies the exploration of cycling passes available in France\nand referenced on [cols-cyclisme.com/](https://www.cols-cyclisme.com/).\nStatistics on almost 2,500 climbs are listed here.\n\nThe aim of the site is to freely explore French cycling climbs.\nThese can be selected according to difficulty criteria (length, altitude difference, etc.)\nor can be selected within the radius of a starting point. \n\nThe website will soon be enhanced with new pages, including\nnumerous statistics based on data\ndata on cycling climbs. \n`\n\n\n\n\n\n\n\nprofile = md`![](https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/catbike.png)`"
  },
  {
    "objectID": "statistics.html",
    "href": "statistics.html",
    "title": "Statistiques",
    "section": "",
    "text": "Page √† venir"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "climb tracker üöµ",
    "section": "",
    "text": "raw = {\n  // URLs of the GeoJSON files\n  const geojsonUrl1 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/alpes-nord-sommets.geojson\";\n  const geojsonUrl2 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/alpes-sud-sommets.geojson\";\n  const geojsonUrl3 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/pyrenees.geojson\";\n  const geojsonUrl4 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/massif-central.geojson\";\n  const geojsonUrl5 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/vosges.geojson\";\n  const geojsonUrl6 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/autres-massifs.geojson\";\n  const geojsonUrl7 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/autres.geojson\";\n  const geojsonUrl8 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/missed.geojson\";\n\n  // Fetch\n  const fetchGeoJSON1 = fetch(geojsonUrl1).then(response =&gt; response.json());\n  const fetchGeoJSON2 = fetch(geojsonUrl2).then(response =&gt; response.json());\n  const fetchGeoJSON3 = fetch(geojsonUrl3).then(response =&gt; response.json());\n  const fetchGeoJSON4 = fetch(geojsonUrl4).then(response =&gt; response.json());\n  const fetchGeoJSON5 = fetch(geojsonUrl5).then(response =&gt; response.json());\n  const fetchGeoJSON6 = fetch(geojsonUrl6).then(response =&gt; response.json());\n  const fetchGeoJSON7 = fetch(geojsonUrl7).then(response =&gt; response.json());\n  const fetchGeoJSON8 = fetch(geojsonUrl8).then(response =&gt; response.json());\n\n  // When both GeoJSONs are fetched, combine them\n  let raw = Promise.all([\n    fetchGeoJSON1, fetchGeoJSON2,\n    fetchGeoJSON3, fetchGeoJSON4,\n    fetchGeoJSON5, fetchGeoJSON6,\n    fetchGeoJSON7, fetchGeoJSON8\n    ]).then(values =&gt; {\n    const combinedFeatures = [\n      ...values[0].features,\n      ...values[1].features,\n      ...values[2].features,\n      ...values[3].features,\n      ...values[4].features,\n      ...values[5].features,\n      ...values[6].features,\n      ...values[7].features\n      ]; // Combine features from both GeoJSON files\n\n    // Create a new GeoJSON object with combined features\n    const combinedGeoJSON = {\n      type: \"FeatureCollection\",\n      features: combinedFeatures\n    };\n\n    return combinedGeoJSON\n\n  }).catch(error =&gt; {\n    console.error(\"Error fetching or combining GeoJSONs:\", error);\n  });\n\n  return raw\n}\n\n\n\n\n\n\n\nsommets = geo.filter(raw, (d) =&gt; !d.vtt)\ncols = sommets.features.map(d=&gt;d.properties)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\navailableHeight = window.innerHeight\nscreenHeight = 0.9*(availableHeight - document.getElementById(\"quarto-header\").offsetHeight)\navailableWidth = window.innerWidth\nmapWidth = (width &gt; 400) ? 0.4*width : 0.95*width \nmapHeight = (width &gt; 400) ? 0.85*screenHeight : 0.5*screenHeight\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Range(range, options = {}) {\n  const [min, max] = range;\n  const {\n    className = \"Range\",\n    vertical = false,\n    label = null,\n    format = (x) =&gt; +x,\n    step = 1,\n    value = (min + max) / 2,\n    style = \"\",\n    labelStyle = \"\",\n    rangeStyle = \"\",\n    valueStyle = \"\",\n    unit = \"\" // New option for specifying a unit\n  } = options;\n  const rangeWrap = htl.html`&lt;div class=${className} style=\"${style}\"&gt;&lt;/div&gt;`;\n  Object.assign(rangeWrap.style, {\n    display: \"inline-flex\",\n    position: \"relative\",\n    userSelect: \"none\",\n    alignItems: \"center\",\n    gap: \"4px\"\n  });\n  const valueDisplay = htl.html`&lt;output style=\"${valueStyle}\"&gt;&lt;/output&gt;`;\n  Object.assign(valueDisplay.style, {\n    display: \"inline-block\"\n  });\n  const rangeInput = htl.html`&lt;input type=range min=${min} max=${max} step=${step} value=${value} style=${rangeStyle}&gt;&lt;/input&gt;`;\n  Object.assign(rangeInput.style, {\n    display: \"inline-block\"\n  });\n  if (vertical) {\n    rangeInput.setAttribute(\"orient\", \"vertical\");\n    rangeInput.style.writingMode = \"bt-lr\";\n    rangeInput.style[\"-webkit-appearance\"] = \"slider-vertical\";\n    rangeInput.style.width = \"8px\";\n  }\n\n  rangeWrap.append(rangeInput, valueDisplay);\n\n  if (label) {\n    const labelElement = htl.html`&lt;label style=${labelStyle}&gt;${label}&lt;/label&gt;`;\n    rangeWrap.prepend(labelElement);\n  }\n\n  rangeInput.oninput = () =&gt; {\n    // Append the unit to the formatted number\n    valueDisplay.textContent = `${format(rangeInput.valueAsNumber)}${unit}`;\n    rangeWrap.value = rangeWrap.valueAsNumber = rangeInput.valueAsNumber;\n    rangeWrap.dispatchEvent(new CustomEvent(\"input\"));\n  };\n\n  rangeInput.oninput(); // Initialize the displayed value\n  return rangeWrap;\n}\n\n\n\n\n\n\n\nstartStop = () =&gt; {\nconst buttons = html`\n&lt;form class=\"form-language-switcher\"&gt;\n  &lt;input value=\"üá´üá∑\" type=\"button\" name=\"stop\" id=\"button_french\" class=\"button_lang current_lang\"&gt;\n  &lt;input value=\"üá¨üáß üá∫üá∏\" type=\"button\" name=\"start\" id=\"button_english\" class=\"button_lang\"&gt;\n&lt;/form&gt;\n`\nbuttons.value = \"fr\"\n\n// French button  \nbuttons.stop.onclick = event =&gt; {\n  buttons.value = \"fr\";\n  event.preventDefault(); // Don‚Äôt submit the form.\n  buttons.dispatchEvent(new CustomEvent(\"input\"));                      \n  const french = document.getElementById(\"button_french\") ;\n  const english = document.getElementById(\"button_english\") ;\n  french.classList.add(\"current_lang\")\n  english.classList.remove(\"current_lang\")\n}\n// English button  \nbuttons.start.onclick = event =&gt; {\n  buttons.value = \"en\";\n  event.preventDefault(); // Don‚Äôt submit the form.\n  buttons.dispatchEvent(new CustomEvent(\"input\")); \n  const french = document.getElementById(\"button_french\") ;\n  const english = document.getElementById(\"button_english\") ;\n  english.classList.add(\"current_lang\")\n  french.classList.remove(\"current_lang\")\n}\n\nreturn buttons\n}\n\n\n\n\n\n\n\n\ncategory_label = html`&lt;span class=\"info-container\"&gt;\n  &lt;span style=\"color: orange\" class=\"infopicto\"&gt;${getIconSvg(\"info\")}\n    &lt;span class=\"tooltip-content\"&gt;\n      ${lang == 'fr' ? 'Version simplifi√©e de la classification UCI &lt;br&gt;D√©nivel√©:' : 'Simplified UCI classification&lt;br&gt;Gain:'}\n      ${classificationDetails}\n    &lt;/span&gt;\n  &lt;/span&gt;\n&lt;/span&gt;`\n\n\n\n\n\n\n\nclassificationDetails = `\n&lt;ul&gt;\n  &lt;li&gt;Cat 4: 80 - 159m&lt;/li&gt;\n  &lt;li&gt;Cat 3: 160 - 319m&lt;/li&gt;\n  &lt;li&gt;Cat 2: 320 - 639m&lt;/li&gt;\n  &lt;li&gt;Cat 1: 640 - 799m&lt;/li&gt;\n  &lt;li&gt;HC: 800m and more &lt;/li&gt;\n&lt;/ul&gt;\n`\n\n\n\n\n\n\n\n\nfunction slice(...options) {\n  return array =&gt; array.slice(...options);\n}\n\n\n\n\n\n\n\nfunction get_nearest_point(e, points){\n  // 'e.latlng' gives you the LatLng object of where the mouse currently is\n  const mouseLatLng = e.latlng;\n  const targetPoint = turf.point([mouseLatLng.lng, mouseLatLng.lat]);\n  var nearest = turf.nearestPoint(targetPoint, points);\n  return nearest\n}\n\n\n\n\n\n\n\n// Function to convert array of coordinate arrays to a FeatureCollection\nfunction toGeoJSONFeatureCollection(data) {\n  const coordsArray = data.features.map(d =&gt; d.geometry.coordinates);\n  // Map each coordinate array to a GeoJSON Point feature\n  const features = coordsArray.flat().map(coords =&gt; ({\n    \"type\": \"Feature\",\n    \"properties\": {\n      // If you have properties to include, add them here\n      \"altitude\": coords[2]  // Example property\n    },\n    \"geometry\": {\n      \"type\": \"Point\",\n      \"coordinates\": [coords[0], coords[1]]  // Only longitude and latitude are used for Point\n    }\n  }));\n\n  // Return as a FeatureCollection\n  return {\n    \"type\": \"FeatureCollection\",\n    \"features\": features\n  };\n}\n\n\n\n\n\n\n\nfunction normalize(gj) {\n    if (!gj || !gj.type) return null;\n    var types = {\n        Point: 'geometry',\n        MultiPoint: 'geometry',\n        LineString: 'geometry',\n        MultiLineString: 'geometry',\n        Polygon: 'geometry',\n        MultiPolygon: 'geometry',\n        GeometryCollection: 'geometry',\n        Feature: 'feature',\n        FeatureCollection: 'featurecollection'\n    };\n    var type = types[gj.type];\n    if (!type) return null;\n\n    if (type === 'geometry') {\n        return {\n            type: 'FeatureCollection',\n            features: [{\n                type: 'Feature',\n                properties: {},\n                geometry: gj\n            }]\n        };\n    } else if (type === 'feature') {\n        return {\n            type: 'FeatureCollection',\n            features: [gj]\n        };\n    } else if (type === 'featurecollection') {\n        return gj;\n    }\n}\n\n\n\n\n\n\n\nfunction fetchAndNormalizeGeoJSON(id, baseUrl) {\n    return fetch(`${baseUrl}/${id}.geojson`)\n        .then(response =&gt; response.json())\n        .then(normalize) // Assuming `normalize` function is available in the scope\n        .catch(error =&gt; {\n          console.error(`Failed to fetch or normalize GeoJSON for ID: ${id}`, error);\n          return null;\n        }) ;\n}\n\n\n\n\n\n\n\nfunction mergeGeoJSONs(ids, baseUrl) {\n    const promises = ids.map(id =&gt; fetchAndNormalizeGeoJSON(id, baseUrl));\n\n    return Promise.all(promises)\n        .then(normalizedGeoJSONs =&gt; {\n            return normalizedGeoJSONs.reduce((output, geojson) =&gt; {\n                if (geojson && geojson.features) {\n                    output.features.push(...geojson.features);\n                }\n                return output;\n            }, {\n                type: 'FeatureCollection',\n                features: []\n            });\n        });\n}\n\n\n\n\n\n\n\nasync function getCombinedGeoJSON(ids, baseUrl) {\n  try {\n    let combinedGeoJSON = await mergeGeoJSONs(ids, baseUrl);\n    console.log('Combined GeoJSON:', combinedGeoJSON);\n    // Handle the combined GeoJSON (e.g., display on map)\n    return combinedGeoJSON; // This will be a GeoJSON object\n  } catch (error) {\n    console.error('An error occurred while merging GeoJSONs:', error);\n    // Handle the error appropriately\n  }\n}\n\n\n\n\n\n\n\n\nimport {getIconSvg} from '@saneef/feather-icons'\n\n\n\n\n\n\n\nturf = require(\"@turf/turf@6\")\n\n\n\n\n\n\n\ngeo = require(\"geotoolbox@2\")\n\n\n\n\n\n\n\nPlot = require(\"https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.13/dist/plot.umd.min.js\")\n\n\n\n\n\n\n\nimport {multiAutoSelect} from \"@linogaliana/multi-auto-select\"\n\n\n\n\n\n\n\n\nfunction rank_ascent(sommetsGeoJson, variableToPlot, selectedClimb, lang = \"fr\"){\n const namelabel = (lang == \"fr\") ? \"Ascension\" : \"Ascent\" \n const gainlabel = (lang == \"fr\") ? \"D√©nivel√© positif\" : \"Elevation gain\" \n const massiflabel = (lang == \"fr\") ? \"Massif\" : \"Mountain side\" \n const percentlabel = (lang == \"fr\") ? \"Pente moyenne\" : \"Average slope\" \n let p = Plot.plot({\n  color: {\n      type: \"sequential\",\n      scheme: \"Turbo\"\n    },\n    marks: [\n      Plot.ruleX(\n        sommetsGeoJson.features.map(d=&gt;d.properties),\n        {\n          x: variableToPlot, stroke: variableToPlot,\n          channels: {\n            nom: {label: namelabel, value: \"nom\"},\n            deniv: {label: gainlabel, value: (d) =&gt; `${d.denivellation}m`},\n            massif: {label: massiflabel, value: \"massif\"},\n            percent: {value: (d) =&gt; `${d.percent_moyen}%`, label: percentlabel},\n            },\n          tip: {\n            format: {\n              stroke : false\n            },\n            anchor: \"top\"\n          },\n          strokeOpacity: 0.2}\n      ),\n      Plot.ruleX([selectedClimb], {x : variableToPlot, stroke: \"red\", strokeWidth: 2})\n    ]\n  })\n  return p\n}\n\n\n\n\n\n\n\n\nviewof lang = startStop()\n\n\n\n\n\n\n\nenglish = document.getElementById(\"button_english\")\nfrench = document.getElementById(\"button_french\")\n\nfunction change(lang_on, lang_off) {\n  if (!lang_on.classList.contains(\"current_lang\")) {\n    // if the span that the user clicks on does not have the \"current_lang\" class\n    lang_on.classList.add(\"current_lang\");\n    // add the \"current_lang\" class to it\n    lang_off.classList.remove(\"current_lang\");\n    // remove the \"current_lang\" class from the other span\n  }\n}\n\nenglish.addEventListener(\"click\", function() {\n    change(english, french);\n  }, false\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrench.addEventListener(\"click\", function() {\n    change(french, english);\n  }, false\n);\n\n\n\n\n\n\n\n\n\nlabel_click_map = (lang == \"fr\") ? \"Cliquer sur ce sommet pour en savoir plus\" : \"Click to learn more on that ascent\"\n\n\n\n\n\n\n\nno_ascent_label = (lang == \"fr\") ? \"Pas d'ascension s√©lectionn√©e, cliquer sur la carte pour afficher le profil de l'ascension.\" : \"No selected ascent, click on the map to see ascent details.\"\n\n\n\n\n\n\n\nfinding_ascent_label = (lang == \"fr\") ? \"Ascensions correspondant √† la recherche.\" : \"Ascent corresponding to search criterium.\"\n\n\n\n\n\n\n\nlabel_search_massif = (lang == \"fr\") ?\n  \"Choisir des massifs √† afficher\" : \n  \"Choose climbing regions\"\n\n\n\n\n\n\n\nheader_table_name = (lang == \"fr\") ? \"Ascension\" : \"Ascent\"\nheader_table_departure = (lang == \"fr\") ? \"D√©part\" : \"Start\"\nheader_table_alt = (lang == \"fr\") ? \"Altitude d'arriv√©e\" : \"Arrival height\"\nheader_table_avgpercent = (lang == \"fr\") ? \"Pente moyenne (%)\" : \"Average slope (%)\"\nheader_table_maxpercent = (lang == \"fr\") ? \"Pente maximale (%)\" : \"Maximum slope (%)\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsearch_label_choice = (lang == \"fr\") ? \"Rechercher une ascension\" : \"Finding an ascent\"\nexplorer_label_choice = (lang == \"fr\") ? \"Laissez moi explorer !\" : \"Let me explore !\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nswitch_label =  (lang == \"fr\") ? \"Switch to English version üá¨üáß üá∫üá∏\" : \"Passer √† la version fran√ßaise üá´üá∑\"\n\n\n\n\n\n\n\nmessage_category = lang == 'fr' ? `Version simplifi√©e de la classification UCI ${classificationDetails}` : `Simplified UCI classification ${classificationDetails}`\n\n\n\n\n\n\n\n\nfilter_checkbox_deniv = (lang == \"fr\") ? \"D√©nivel√©\" : \"Height gain\"\nfilter_checkbox_category = (lang == \"fr\") ? \"Cat√©gorie de l'ascension\" : \"Ascent category\"\nfilter_checkbox_length = (lang == \"fr\") ? `Longueur de l'ascension` : \"Ascension length\"\nfilter_checkbox_slope = (lang == \"fr\") ? \"Pente moyenne\" : \"Average slope\"\nfilter_multiselect_group = (lang == \"fr\") ? \"Massif de l'ascension\" : \"Mountain chain\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlabel_search_widget = (lang == \"fr\") ? \"Rechercher un col\" : \"Finding an ascent\"\n\n\n\n\n\n\n\n\nlabel_find_adress = (lang == \"fr\") ?\n  \"1Ô∏è‚É£ Taper une adresse ou une localisation dans la barre de recherche üëáÔ∏è\" :\n  \"1Ô∏è‚É£ Search for a location below üëáÔ∏è\"\n\n\n\n\n\n\n\n\nfunction availableLayers(L, map){\n  \n  // Define tile layers\n  var defaultLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    maxZoom: 19,\n    attribution: '¬© OpenStreetMap contributors'\n  }).addTo(map); // Set as the default layer\n  \n  var topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {\n    maxZoom: 17,\n    attribution: '¬© OpenStreetMap contributors, ¬© OpenTopoMap (CC-BY-SA)'\n  });\n  \n  var cycleLayer = L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {\n    maxZoom: 20,\n    attribution: '¬© OpenStreetMap contributors, ¬© CyclOSM'\n  });\n  \n  // Add the base layers to a layer control\n  var baseLayers = {\n    \"Default\": defaultLayer,\n    \"Topographic\": topoLayer,\n    \"Cycling\": cycleLayer\n  };\n\n  return baseLayers  \n}\n\n\n\n\n\n\n\n\nwhenClicked =  (event) =&gt; {\n  mutable selectedClimb = event.target.feature.properties\n  }\n\n\n\n\n\n\n\nfunction featureEvents(feature, layer) {\n   layer.on({\n     click: whenClicked, //callback functions\n   });\n}\n\n\n\n\n\n\n\nfunction fetchAndDisplayAscentRoute(map, feature, color = 'green') {\n  const id = feature.properties.id;\n  const polylineUrl = `https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/split/${id}.geojson`;\n\n  fetch(polylineUrl)\n    .then(response =&gt; response.json())\n    .then(data =&gt; {\n      // Modify the ascentTrackPolyline function or create a similar one to accept a color parameter\n      ascentTrackPolyline(map, data, feature, color);\n    })\n    .catch(error =&gt; console.error('Error loading the polyline GeoJSON:', error));\n}\n\n\n\n\n\n\n\n\nfunction createIcon(feature, coordinates, color = null){\n        const color_value = (color == null) ? getColorForCategory(feature.properties.category) : color ;\n        const iconUrl = `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color_value}.png`;\n                \n        var icon_color = new L.Icon({\n          iconUrl: iconUrl,\n          shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',\n          iconSize: [25, 41],\n          iconAnchor: [12, 41],\n          popupAnchor: [1, -34],\n          shadowSize: [41, 41]\n        });\n        \n        return L.marker(coordinates, {icon: icon_color})\n\n}\n\n\n\n\n\n\n\nfunction getColorForCategory(category) {\n  switch (category) {\n    case 'Cat 1':\n      return 'blue';\n    case 'Cat 2':\n      return 'green';\n    case 'Cat 3':\n      return 'yellow';\n    case 'Cat 4':\n      return 'orange';\n    case 'HC':\n      return 'red';\n    default:\n      return 'gray';\n  }\n}\n\n\n\n\n\n\n\nfunction ascentTrackPolyline(map, data, feature, color){\n            // Create a polyline from the GeoJSON and add it to the map\n            const polyline = L.geoJson(data, {\n              color: color, // You can customize the polyline's style here\n              weight: 3\n            }).addTo(map);\n\n            // Mouseover for ascent characteristics \n            polyline.on('mouseover', function() {\n              this.bindTooltip(\n                 tooltipRoute(feature),\n                {permanent: false, direction: \"top\"}).openTooltip();\n              \n            });\n\n            // Get mouse location on the map to interactively update a figure\n            const points = toGeoJSONFeatureCollection(data);\n            \n            // polyline.on('mousemove', function(e) {\n              // var nearest = get_nearest_point(e, points)\n              // Update the mutable hover_alt to the altitude\n              // mutable hover_alt = nearest;\n            // });\n\n  return polyline\n}\n\n\n\n\n\n\n\n\nfunction popUpSummit(feature, lang){\n  const AscentName = (lang == \"fr\") ? \"Ascension\" : \"Ascent\" ;\n  const departure = (lang == \"fr\") ? \"D√©part\" : \"Start\" ;\n  const maxAlt = (lang == \"fr\") ? \"Sommet\" : \"Summit\" ;\n  const climbLength = (lang == \"fr\") ? \"Longueur\" : \"Length\" ;\n  const gain = (lang == \"fr\") ? \"D√©nivel√©\" : \"Gain\" ;\n  const averageSlope = (lang == \"fr\") ? \"Pente moyenne\" : \"Average slope\" ; \n  const maxSlope = (lang == \"fr\") ? \"Pente maximale\" : \"Maximum slope\" ; \n  const hrefText =  (lang == \"fr\") ? \"Voir sur\" : \"See on\"\n  const popup = `\n          &lt;b&gt;${AscentName}&lt;/b&gt;: ${feature.properties.nom}&lt;br&gt;\n          &lt;b&gt;${departure}&lt;/b&gt;: ${feature.properties.depart} (${feature.properties.massif})&lt;br&gt; \n          &lt;b&gt;${maxAlt}&lt;/b&gt;: ${feature.properties.alt}m&lt;br&gt;\n          &lt;b&gt;${climbLength}&lt;/b&gt;: ${feature.properties.longueur}km&lt;br&gt;\n          &lt;b&gt;${gain}&lt;/b&gt;: ${feature.properties.denivellation}m (${feature.properties.category})&lt;br&gt;\n          &lt;b&gt;${averageSlope}&lt;/b&gt;: ${feature.properties.percent_moyen}%&lt;br&gt;\n          &lt;b&gt;${maxSlope}&lt;/b&gt;: ${feature.properties.percent_maximal}%&lt;br&gt;\n          &lt;a href=\"${feature.properties.href}\" target=\"_blank\"&gt;${hrefText} &lt;code&gt;https://cols-cyclisme.com/&lt;/code&gt;&lt;/a&gt;\n` \n  return popup\n\n}\n\n\n\n\n\n\n\n\nfunction tooltipSummit(feature){\n  const tooltipMessage = `&lt;b&gt;${feature.properties.nom}&lt;/b&gt;&lt;br&gt;&lt;i&gt;${label_click_map}&lt;/i&gt;`\n  return tooltipMessage\n}\n\n\n\n\n\n\n\nfunction tooltipRoute(feature){\n  const departure = (lang == \"fr\") ? \"D√©part de\" : \"Start from\" ;\n  const maxAlt = (lang == \"fr\") ? \"altitude d'arriv√©e:\" : \"summit at\" ;\n  const climbLength = (lang == \"fr\") ? \"Ascension de\" : \"Climbing length is\" ;\n  const averageSlope = (lang == \"fr\") ? \"de moyenne\" : \"on average\" ; \n  const denivelle = (lang == \"fr\") ? \"D+\" : \"gain\" ; \n  const maxSlope = (lang == \"fr\") ? \"Pente maximale\" : \"Maximum slope\" ; \n\n  const popup = `\n                  &lt;b&gt;${feature.properties.nom}&lt;/b&gt;&lt;br&gt;\n                  ${departure} ${feature.properties.depart} (${maxAlt} ${feature.properties.altitude}m)&lt;br&gt;\n                  ${climbLength} ${feature.properties.longueur}km, ${feature.properties.percent_moyen}% ${averageSlope} (${feature.properties.denivellation}m ${denivelle})&lt;br&gt;\n                  &lt;i&gt;${maxSlope}:  ${feature.properties.percent_maximal}%&lt;/i&gt;\n  `\n  return popup\n}\n\n\n\n\n\n\n\nfunction container_ascent(feature, lang, width){\n\n  const imageInitial = feature.properties.profil_image_url ;\n\n  const imageURL = imageInitial.replace(\n          'profils.cols-cyclisme.com',\n          'minio.lab.sspcloud.fr/lgaliana/cyclisme/data/images'\n        ) ;\n\n  let container ;\n\n  if (width &gt; 400){\n    container = `\n      &lt;div id=\"container-statistics\" style=\"display: flex; flex-direction: column;\"&gt;\n        &lt;div style=\"display: flex; justify-content: space-between; align-items: flex-start; width: 100%;\"&gt;\n          &lt;div style=\"width: 20%;\"&gt;\n            ${popUpSummit(feature, lang, width &gt; 400)}\n          &lt;/div&gt;\n          &lt;div id=\"ascent-image\" style=\"width: 80%;\"&gt;\n            &lt;img src=\"${imageURL}\" alt=\"\" style=\"max-width: 100%; height: auto; max-height:${screenHeight*0.5};\"&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div id=\"stats-denivellation\" style=\"width: 100%;\"&gt;\n          &lt;!-- Content for stats-denivellation goes here --&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n          ` ;\n  } else{\n    container = `\n      &lt;div id=\"container-statistics\" style=\"display: flex; flex-direction: column;\"&gt;\n          &lt;div style=\"width: 100%;\"&gt;\n            ${popUpSummit(feature, lang, width &gt; 400)}\n          &lt;/div&gt;\n        &lt;div id=\"stats-denivellation\" style=\"width: 100%;\"&gt;\n          &lt;!-- Content for stats-denivellation goes here --&gt;\n        &lt;/div&gt;\n          &lt;div id=\"ascent-image\" style=\"width: 80%;\"&gt;\n            &lt;img src=\"${imageURL}\" alt=\"\" style=\"max-width: 100%; height: auto; max-height:${screenHeight*0.5};\"&gt;\n          &lt;/div&gt;\n      &lt;/div&gt;\n    `\n  }\n\n  return container\n}\n\n\n\n\n\n\n\nmax_length = d3.max(\n  sommets.features.map(d=&gt;d.properties.longueur)\n)\n\nmax_denivelation = d3.max(\n  sommets.features.map(d=&gt;d.properties.denivellation)\n)\n\nmax_slope = d3.max(\n  sommets.features.map(d=&gt;d.properties.percent_moyen)\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncategories = unique(sommets.features.map(d =&gt; d.properties.category))\n\n\n\n\n\n\n\nmassifs = unique(sommets.features.map(d =&gt; d.properties.massif))\n\n\n\n\n\n\n\nselectedRoute = d3.json(`https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/split/${selectedClimb.id}.geojson`)\n\n\n\n\n\n\n\ndetails_altitude = selectedRoute.features[0].geometry.coordinates.map((coord, index) =&gt; {\n  return { index: index, altitude: coord[2]}\n});\n\n\n\n\n\n\n\nprinted_points = {\n  let printed_points;\n  if (mode === \"explorer\") {\n      printed_points = geo.filter(sommets, (d) =&gt; filter_active_width(d, filter_choice));\n  } else {\n      const searchIds = search.map(s =&gt; s.id);\n      printed_points = geo.filter(sommets, (d) =&gt; searchIds.includes(d.id));\n      if (width &lt; 400) {\n        console.log(printed_points)\n        printed_points = geo.properties.head({\n          x: printed_points, // a geojson\n          field: \"nom\", // a colname (string)\n          nb: 100 // default:10. Number of features to get. \n        })\n      }\n\n  }\n  return printed_points\n}\n\n\n\n\n\n\n\n\nmutable selectedClimb = null\n\n\n\n\n\n\n\nunique = (arr) =&gt; [...new Set(arr)]\n\n\n\n\n\n\n\nfunction sparkbar(max) {\n  return x =&gt; htl.html`&lt;div class=\"sparkbar\" style=\"width: ${100 * x / max}%;\"&gt;${x.toLocaleString(\"en\")}&lt;/div&gt;`\n}\n\n\n\n\n\n\n\nwidget_to_print = {\n  switch (filter_choice) {\n    case filter_checkbox_length:\n      console.log(\"Choosing filter by length\")\n      return Inputs.bind(\n          Range([1, max_length], {unit: \"km\"}),\n          viewof climb_length\n      )\n    case filter_checkbox_deniv:\n      console.log(\"Choosing filter by height gain\")\n      return Inputs.bind(\n        Range([1, max_denivelation], {unit: \"m\", value: 1200}),\n        viewof climb_height\n      )\n    case filter_checkbox_category:\n      console.log(\"Choosing filter by category\")\n      return Inputs.bind(\n        Inputs.checkbox(\n          categories,\n          {\n            sort: \"descending\",\n            value: [\"HC\", \"Cat 1\"],\n            //label: category_label\n          }\n        ),\n        viewof category\n      )\n    case filter_checkbox_slope:\n      console.log(\"Choosing filter by average slope\")\n      return Inputs.bind(\n        Range([0, max_slope], {unit: \"%\", step: 0.2}),\n        viewof climb_slope\n      )\n    case filter_multiselect_group:\n      console.log(\"Choosing filter by climbing group\")\n      return Inputs.bind(\n         multiAutoSelect({\n          options: massifs.sort(),\n          placeholder: label_search_massif,\n          value: \"Arves et Grandes Rousses, France\"\n        }),\n         viewof selected_massif\n      )\n    default:\n      return false\n  }\n}\n\nfunction filter_active_width(d, widget) {\n  switch (widget) {\n    case filter_checkbox_deniv:\n      return d.denivellation &gt; climb_height;\n    case filter_checkbox_length:\n      return d.longueur &gt; climb_length;\n    case filter_checkbox_category:\n      return category.includes(d.category);\n    case filter_checkbox_slope:\n      return d.percent_moyen &gt; climb_slope;\n    case filter_multiselect_group :\n      return selected_massif.includes(d.massif);\n    default:\n      return false; // or any default case handling you prefer\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof mode = Inputs.radio(new Map([[search_label_choice, \"search\"], [explorer_label_choice, \"explorer\"]]), {value: \"explorer\"})\n\n\n\n\n\n\n\n\nviewof search = Inputs.search(\n  cols, {placeholder: label_search_widget, datalist: [\"nom\", \"d√©part\", \"massif\"]}\n)\n\n\n\n\n\n\n\ntable_selected = Inputs.table(\n  search,\n  {\n    columns: [\n      \"nom\",\n      \"depart\",\n      \"longueur\",\n      \"denivellation\",\n      \"altitude\",\n      \"percent_moyen\",\n      \"percent_maximal\"\n    ],\n    header: {\n        nom: header_table_name,\n        depart: header_table_departure,\n        longueur: filter_checkbox_length,\n        denivellation: filter_checkbox_deniv,\n        altitude: header_table_alt,\n        percent_moyen: header_table_avgpercent,\n        percent_maximal: header_table_maxpercent\n      },\n    sort: \"denivellation\", reverse: true\n})\n\n\n\n\n\n\n\nviewof filter_choice = Inputs.select(\n  [filter_checkbox_length, filter_checkbox_deniv, filter_checkbox_category, filter_checkbox_slope, filter_multiselect_group],\n  {value: filter_checkbox_deniv}\n  )\n\n\n\n\n\n\n\n\nviewof selected_massif = multiAutoSelect({\n  options: massifs.sort(),\n  placeholder: label_search_massif,\n  value: \"Arves et Grandes Rousses, France\"\n})\n\n\n\n\n\n\n\nviewof climb_slope = Inputs.range([0, max_slope], {step: 0.2})\nviewof climb_length = Inputs.range([0, max_length], {step: 1})\nviewof climb_height = Inputs.range([0, max_denivelation], {step: 1})\nviewof category = Inputs.checkbox(\n  categories,\n  {sort: \"descending\", value: [\"HC\", \"Cat 1\"]}\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhtml\n`\n&lt;div class=\"lang-selector\"&gt;${viewof lang}&lt;/div&gt;\n&lt;div class=\"container\"&gt;\n  &lt;div class=\"mode-selector\"&gt;${viewof mode}&lt;/div&gt;\n&lt;div/&gt;\n`\n\n\n\n\n\n\n\n\nselectors = {\n  let selectors ;\n\n  if (mode == \"explorer\"){\n    selectors = html\n    `\n    &lt;div class=\"container\"&gt;\n      &lt;div class=\"select-container\"&gt;\n        &lt;div&gt;${viewof filter_choice}&lt;/div&gt;\n        &lt;div class=\"visible-widget\"&gt;${widget_to_print}&lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    `\n    return selectors\n  }\n\n  selectors = html`&lt;div class=\"search-widget\"&gt;${viewof search}&lt;/div&gt;`\n  return selectors\n}\n\n\n\n\n\n\n\nhtml`${selectors}`\n\n\n\n\n\n\n\n\n(width &gt; 400) ?\n  html`\n  &lt;div class=\"main-container\"&gt;\n    &lt;div id = \"leafletmap\" style=\"width: 40%;\"&gt;${leafletmap}&lt;/div&gt;\n    &lt;div class=\"column spacer\" style=\"width: 2%;\"&gt;\n        &lt;!-- Spacer column --&gt;\n    &lt;/div&gt;\n    &lt;div style=\"width: 58%;\"&gt;\n      &lt;div id=\"available-ascent\"&gt;\n      &lt;div&gt;&lt;i&gt;${finding_ascent_label}&lt;/i&gt;&lt;/div&gt;\n      &lt;br&gt;\n      ${table_selected}\n      &lt;br&gt;\n      &lt;/div&gt;\n    &lt;div id=\"statsElement\"&gt;&lt;i&gt;${no_ascent_label}&lt;/i&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  ` :\n  html`\n    &lt;div id = \"leafletmap\" style=\"width: 100%;\"&gt;${leafletmap}&lt;/div&gt;\n    &lt;div style=\"width: 100%;\"&gt;\n      &lt;div id=\"available-ascent\"&gt;\n      &lt;div&gt;&lt;i&gt;${finding_ascent_label}&lt;/i&gt;&lt;/div&gt;\n      &lt;br&gt;\n      ${table_selected}\n      &lt;br&gt;\n      &lt;/div&gt;\n    &lt;div id=\"statsElement\"&gt;&lt;i&gt;${no_ascent_label}&lt;/i&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  `\n\n\n\n\n\n\n\nleafletmap = {\n\n  // Create a container element for leaflet map\n  let parent = DOM.element('div', { style: `width:${mapWidth}px;height:${mapHeight}px` });\n  yield parent;\n  var map = L.map(parent).setView([0, 0], 5);\n\n  // Add the layer control to the map\n  let baseLayers = availableLayers(L, map) ;\n  L.control.layers(baseLayers).addTo(map);\n\n\n  // Define a function that will be called for each feature in your GeoJSON layer\n  function popEventSummit(feature, layer) {\n\n      // Add mouseover event listener\n      layer.on('mouseover', function() {\n        const tooltipMessage = tooltipSummit(feature) ;\n        layer.bindTooltip(\n          tooltipMessage, {permanent: false, direction: \"auto\"}\n          ).openTooltip();\n      });\n\n      // Create popup for ascent summit\n      layer.bindPopup(\n        popUpSummit(feature, lang)\n      );\n\n     layer.on({\n       click: whenClicked, //callback functions\n     });\n      \n      // Existing event listener for popup opens\n      layer.on('popupopen', function() {\n        const statsElement = document.getElementById('statsElement');\n        const availableAscents = document.getElementById('available-ascent');        \n        \n        // Update the content of 'statsElement' with the desired statistics from 'feature.properties'\n        statsElement.innerHTML = container_ascent(feature, lang, width) ;\n        availableAscents.innerHTML = \"\" ;\n\n        // Fetch route for selected ascent\n        fetchAndDisplayAscentRoute(map, feature, 'red');\n      });\n\n  }\n  \n    var geojsonLayer = L.geoJson(printed_points, {\n      onEachFeature: popEventSummit,\n      pointToLayer: function(feature, coordinates) {\n        return createIcon(feature, coordinates)        \n      }\n    }).addTo(map);\n  \n    geojsonLayer.setStyle({\n      color: 'red',\n      weight: 5\n  });\n\n  \n    map.fitBounds(geojsonLayer.getBounds())\n}\n\n\n\n\n\n\n\n{\n  document.querySelector('#stats-denivellation').appendChild(\n    rank_ascent(sommets, \"denivellation\", selectedClimb, lang)\n  )\n  document.querySelector('#stats-denivellation').appendChild(\n    rank_ascent(sommets, \"longueur\", selectedClimb, lang)\n  )\n\n}"
  },
  {
    "objectID": "around.html",
    "href": "around.html",
    "title": "climb tracker üöµ",
    "section": "",
    "text": "raw = {\n  // URLs of the GeoJSON files\n  const geojsonUrl1 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/alpes-nord-sommets.geojson\";\n  const geojsonUrl2 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/alpes-sud-sommets.geojson\";\n  const geojsonUrl3 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/pyrenees.geojson\";\n  const geojsonUrl4 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/massif-central.geojson\";\n  const geojsonUrl5 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/vosges.geojson\";\n  const geojsonUrl6 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/autres-massifs.geojson\";\n  const geojsonUrl7 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/autres.geojson\";\n  const geojsonUrl8 = \"https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/missed.geojson\";\n\n  // Fetch\n  const fetchGeoJSON1 = fetch(geojsonUrl1).then(response =&gt; response.json());\n  const fetchGeoJSON2 = fetch(geojsonUrl2).then(response =&gt; response.json());\n  const fetchGeoJSON3 = fetch(geojsonUrl3).then(response =&gt; response.json());\n  const fetchGeoJSON4 = fetch(geojsonUrl4).then(response =&gt; response.json());\n  const fetchGeoJSON5 = fetch(geojsonUrl5).then(response =&gt; response.json());\n  const fetchGeoJSON6 = fetch(geojsonUrl6).then(response =&gt; response.json());\n  const fetchGeoJSON7 = fetch(geojsonUrl7).then(response =&gt; response.json());\n  const fetchGeoJSON8 = fetch(geojsonUrl8).then(response =&gt; response.json());\n\n  // When both GeoJSONs are fetched, combine them\n  let raw = Promise.all([\n    fetchGeoJSON1, fetchGeoJSON2,\n    fetchGeoJSON3, fetchGeoJSON4,\n    fetchGeoJSON5, fetchGeoJSON6,\n    fetchGeoJSON7, fetchGeoJSON8\n    ]).then(values =&gt; {\n    const combinedFeatures = [\n      ...values[0].features,\n      ...values[1].features,\n      ...values[2].features,\n      ...values[3].features,\n      ...values[4].features,\n      ...values[5].features,\n      ...values[6].features,\n      ...values[7].features\n      ]; // Combine features from both GeoJSON files\n\n    // Create a new GeoJSON object with combined features\n    const combinedGeoJSON = {\n      type: \"FeatureCollection\",\n      features: combinedFeatures\n    };\n\n    return combinedGeoJSON\n\n  }).catch(error =&gt; {\n    console.error(\"Error fetching or combining GeoJSONs:\", error);\n  });\n\n  return raw\n}\n\n\n\n\n\n\n\nsommets = geo.filter(raw, (d) =&gt; !d.vtt)\ncols = sommets.features.map(d=&gt;d.properties)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\navailableHeight = window.innerHeight\nscreenHeight = 0.9*(availableHeight - document.getElementById(\"quarto-header\").offsetHeight)\navailableWidth = window.innerWidth\nmapWidth = (width &gt; 400) ? 0.4*width : 0.95*width \nmapHeight = (width &gt; 400) ? 0.85*screenHeight : 0.5*screenHeight\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Range(range, options = {}) {\n  const [min, max] = range;\n  const {\n    className = \"Range\",\n    vertical = false,\n    label = null,\n    format = (x) =&gt; +x,\n    step = 1,\n    value = (min + max) / 2,\n    style = \"\",\n    labelStyle = \"\",\n    rangeStyle = \"\",\n    valueStyle = \"\",\n    unit = \"\" // New option for specifying a unit\n  } = options;\n  const rangeWrap = htl.html`&lt;div class=${className} style=\"${style}\"&gt;&lt;/div&gt;`;\n  Object.assign(rangeWrap.style, {\n    display: \"inline-flex\",\n    position: \"relative\",\n    userSelect: \"none\",\n    alignItems: \"center\",\n    gap: \"4px\"\n  });\n  const valueDisplay = htl.html`&lt;output style=\"${valueStyle}\"&gt;&lt;/output&gt;`;\n  Object.assign(valueDisplay.style, {\n    display: \"inline-block\"\n  });\n  const rangeInput = htl.html`&lt;input type=range min=${min} max=${max} step=${step} value=${value} style=${rangeStyle}&gt;&lt;/input&gt;`;\n  Object.assign(rangeInput.style, {\n    display: \"inline-block\"\n  });\n  if (vertical) {\n    rangeInput.setAttribute(\"orient\", \"vertical\");\n    rangeInput.style.writingMode = \"bt-lr\";\n    rangeInput.style[\"-webkit-appearance\"] = \"slider-vertical\";\n    rangeInput.style.width = \"8px\";\n  }\n\n  rangeWrap.append(rangeInput, valueDisplay);\n\n  if (label) {\n    const labelElement = htl.html`&lt;label style=${labelStyle}&gt;${label}&lt;/label&gt;`;\n    rangeWrap.prepend(labelElement);\n  }\n\n  rangeInput.oninput = () =&gt; {\n    // Append the unit to the formatted number\n    valueDisplay.textContent = `${format(rangeInput.valueAsNumber)}${unit}`;\n    rangeWrap.value = rangeWrap.valueAsNumber = rangeInput.valueAsNumber;\n    rangeWrap.dispatchEvent(new CustomEvent(\"input\"));\n  };\n\n  rangeInput.oninput(); // Initialize the displayed value\n  return rangeWrap;\n}\n\n\n\n\n\n\n\nstartStop = () =&gt; {\nconst buttons = html`\n&lt;form class=\"form-language-switcher\"&gt;\n  &lt;input value=\"üá´üá∑\" type=\"button\" name=\"stop\" id=\"button_french\" class=\"button_lang current_lang\"&gt;\n  &lt;input value=\"üá¨üáß üá∫üá∏\" type=\"button\" name=\"start\" id=\"button_english\" class=\"button_lang\"&gt;\n&lt;/form&gt;\n`\nbuttons.value = \"fr\"\n\n// French button  \nbuttons.stop.onclick = event =&gt; {\n  buttons.value = \"fr\";\n  event.preventDefault(); // Don‚Äôt submit the form.\n  buttons.dispatchEvent(new CustomEvent(\"input\"));                      \n  const french = document.getElementById(\"button_french\") ;\n  const english = document.getElementById(\"button_english\") ;\n  french.classList.add(\"current_lang\")\n  english.classList.remove(\"current_lang\")\n}\n// English button  \nbuttons.start.onclick = event =&gt; {\n  buttons.value = \"en\";\n  event.preventDefault(); // Don‚Äôt submit the form.\n  buttons.dispatchEvent(new CustomEvent(\"input\")); \n  const french = document.getElementById(\"button_french\") ;\n  const english = document.getElementById(\"button_english\") ;\n  english.classList.add(\"current_lang\")\n  french.classList.remove(\"current_lang\")\n}\n\nreturn buttons\n}\n\n\n\n\n\n\n\n\ncategory_label = html`&lt;span class=\"info-container\"&gt;\n  &lt;span style=\"color: orange\" class=\"infopicto\"&gt;${getIconSvg(\"info\")}\n    &lt;span class=\"tooltip-content\"&gt;\n      ${lang == 'fr' ? 'Version simplifi√©e de la classification UCI &lt;br&gt;D√©nivel√©:' : 'Simplified UCI classification&lt;br&gt;Gain:'}\n      ${classificationDetails}\n    &lt;/span&gt;\n  &lt;/span&gt;\n&lt;/span&gt;`\n\n\n\n\n\n\n\nclassificationDetails = `\n&lt;ul&gt;\n  &lt;li&gt;Cat 4: 80 - 159m&lt;/li&gt;\n  &lt;li&gt;Cat 3: 160 - 319m&lt;/li&gt;\n  &lt;li&gt;Cat 2: 320 - 639m&lt;/li&gt;\n  &lt;li&gt;Cat 1: 640 - 799m&lt;/li&gt;\n  &lt;li&gt;HC: 800m and more &lt;/li&gt;\n&lt;/ul&gt;\n`\n\n\n\n\n\n\n\n\nfunction slice(...options) {\n  return array =&gt; array.slice(...options);\n}\n\n\n\n\n\n\n\nfunction get_nearest_point(e, points){\n  // 'e.latlng' gives you the LatLng object of where the mouse currently is\n  const mouseLatLng = e.latlng;\n  const targetPoint = turf.point([mouseLatLng.lng, mouseLatLng.lat]);\n  var nearest = turf.nearestPoint(targetPoint, points);\n  return nearest\n}\n\n\n\n\n\n\n\n// Function to convert array of coordinate arrays to a FeatureCollection\nfunction toGeoJSONFeatureCollection(data) {\n  const coordsArray = data.features.map(d =&gt; d.geometry.coordinates);\n  // Map each coordinate array to a GeoJSON Point feature\n  const features = coordsArray.flat().map(coords =&gt; ({\n    \"type\": \"Feature\",\n    \"properties\": {\n      // If you have properties to include, add them here\n      \"altitude\": coords[2]  // Example property\n    },\n    \"geometry\": {\n      \"type\": \"Point\",\n      \"coordinates\": [coords[0], coords[1]]  // Only longitude and latitude are used for Point\n    }\n  }));\n\n  // Return as a FeatureCollection\n  return {\n    \"type\": \"FeatureCollection\",\n    \"features\": features\n  };\n}\n\n\n\n\n\n\n\nfunction normalize(gj) {\n    if (!gj || !gj.type) return null;\n    var types = {\n        Point: 'geometry',\n        MultiPoint: 'geometry',\n        LineString: 'geometry',\n        MultiLineString: 'geometry',\n        Polygon: 'geometry',\n        MultiPolygon: 'geometry',\n        GeometryCollection: 'geometry',\n        Feature: 'feature',\n        FeatureCollection: 'featurecollection'\n    };\n    var type = types[gj.type];\n    if (!type) return null;\n\n    if (type === 'geometry') {\n        return {\n            type: 'FeatureCollection',\n            features: [{\n                type: 'Feature',\n                properties: {},\n                geometry: gj\n            }]\n        };\n    } else if (type === 'feature') {\n        return {\n            type: 'FeatureCollection',\n            features: [gj]\n        };\n    } else if (type === 'featurecollection') {\n        return gj;\n    }\n}\n\n\n\n\n\n\n\nfunction fetchAndNormalizeGeoJSON(id, baseUrl) {\n    return fetch(`${baseUrl}/${id}.geojson`)\n        .then(response =&gt; response.json())\n        .then(normalize) // Assuming `normalize` function is available in the scope\n        .catch(error =&gt; {\n          console.error(`Failed to fetch or normalize GeoJSON for ID: ${id}`, error);\n          return null;\n        }) ;\n}\n\n\n\n\n\n\n\nfunction mergeGeoJSONs(ids, baseUrl) {\n    const promises = ids.map(id =&gt; fetchAndNormalizeGeoJSON(id, baseUrl));\n\n    return Promise.all(promises)\n        .then(normalizedGeoJSONs =&gt; {\n            return normalizedGeoJSONs.reduce((output, geojson) =&gt; {\n                if (geojson && geojson.features) {\n                    output.features.push(...geojson.features);\n                }\n                return output;\n            }, {\n                type: 'FeatureCollection',\n                features: []\n            });\n        });\n}\n\n\n\n\n\n\n\nasync function getCombinedGeoJSON(ids, baseUrl) {\n  try {\n    let combinedGeoJSON = await mergeGeoJSONs(ids, baseUrl);\n    console.log('Combined GeoJSON:', combinedGeoJSON);\n    // Handle the combined GeoJSON (e.g., display on map)\n    return combinedGeoJSON; // This will be a GeoJSON object\n  } catch (error) {\n    console.error('An error occurred while merging GeoJSONs:', error);\n    // Handle the error appropriately\n  }\n}\n\n\n\n\n\n\n\n\nimport {getIconSvg} from '@saneef/feather-icons'\n\n\n\n\n\n\n\nturf = require(\"@turf/turf@6\")\n\n\n\n\n\n\n\ngeo = require(\"geotoolbox@2\")\n\n\n\n\n\n\n\nPlot = require(\"https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.13/dist/plot.umd.min.js\")\n\n\n\n\n\n\n\nimport {multiAutoSelect} from \"@linogaliana/multi-auto-select\"\n\n\n\n\n\n\n\n\nfunction rank_ascent(sommetsGeoJson, variableToPlot, selectedClimb, lang = \"fr\"){\n const namelabel = (lang == \"fr\") ? \"Ascension\" : \"Ascent\" \n const gainlabel = (lang == \"fr\") ? \"D√©nivel√© positif\" : \"Elevation gain\" \n const massiflabel = (lang == \"fr\") ? \"Massif\" : \"Mountain side\" \n const percentlabel = (lang == \"fr\") ? \"Pente moyenne\" : \"Average slope\" \n let p = Plot.plot({\n  color: {\n      type: \"sequential\",\n      scheme: \"Turbo\"\n    },\n    marks: [\n      Plot.ruleX(\n        sommetsGeoJson.features.map(d=&gt;d.properties),\n        {\n          x: variableToPlot, stroke: variableToPlot,\n          channels: {\n            nom: {label: namelabel, value: \"nom\"},\n            deniv: {label: gainlabel, value: (d) =&gt; `${d.denivellation}m`},\n            massif: {label: massiflabel, value: \"massif\"},\n            percent: {value: (d) =&gt; `${d.percent_moyen}%`, label: percentlabel},\n            },\n          tip: {\n            format: {\n              stroke : false\n            },\n            anchor: \"top\"\n          },\n          strokeOpacity: 0.2}\n      ),\n      Plot.ruleX([selectedClimb], {x : variableToPlot, stroke: \"red\", strokeWidth: 2})\n    ]\n  })\n  return p\n}\n\n\n\n\n\n\n\n\nviewof lang = startStop()\n\n\n\n\n\n\n\nenglish = document.getElementById(\"button_english\")\nfrench = document.getElementById(\"button_french\")\n\nfunction change(lang_on, lang_off) {\n  if (!lang_on.classList.contains(\"current_lang\")) {\n    // if the span that the user clicks on does not have the \"current_lang\" class\n    lang_on.classList.add(\"current_lang\");\n    // add the \"current_lang\" class to it\n    lang_off.classList.remove(\"current_lang\");\n    // remove the \"current_lang\" class from the other span\n  }\n}\n\nenglish.addEventListener(\"click\", function() {\n    change(english, french);\n  }, false\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrench.addEventListener(\"click\", function() {\n    change(french, english);\n  }, false\n);\n\n\n\n\n\n\n\n\n\nlabel_click_map = (lang == \"fr\") ? \"Cliquer sur ce sommet pour en savoir plus\" : \"Click to learn more on that ascent\"\n\n\n\n\n\n\n\nno_ascent_label = (lang == \"fr\") ? \"Pas d'ascension s√©lectionn√©e, cliquer sur la carte pour afficher le profil de l'ascension.\" : \"No selected ascent, click on the map to see ascent details.\"\n\n\n\n\n\n\n\nfinding_ascent_label = (lang == \"fr\") ? \"Ascensions correspondant √† la recherche.\" : \"Ascent corresponding to search criterium.\"\n\n\n\n\n\n\n\nlabel_search_massif = (lang == \"fr\") ?\n  \"Choisir des massifs √† afficher\" : \n  \"Choose climbing regions\"\n\n\n\n\n\n\n\nheader_table_name = (lang == \"fr\") ? \"Ascension\" : \"Ascent\"\nheader_table_departure = (lang == \"fr\") ? \"D√©part\" : \"Start\"\nheader_table_alt = (lang == \"fr\") ? \"Altitude d'arriv√©e\" : \"Arrival height\"\nheader_table_avgpercent = (lang == \"fr\") ? \"Pente moyenne (%)\" : \"Average slope (%)\"\nheader_table_maxpercent = (lang == \"fr\") ? \"Pente maximale (%)\" : \"Maximum slope (%)\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsearch_label_choice = (lang == \"fr\") ? \"Rechercher une ascension\" : \"Finding an ascent\"\nexplorer_label_choice = (lang == \"fr\") ? \"Laissez moi explorer !\" : \"Let me explore !\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nswitch_label =  (lang == \"fr\") ? \"Switch to English version üá¨üáß üá∫üá∏\" : \"Passer √† la version fran√ßaise üá´üá∑\"\n\n\n\n\n\n\n\nmessage_category = lang == 'fr' ? `Version simplifi√©e de la classification UCI ${classificationDetails}` : `Simplified UCI classification ${classificationDetails}`\n\n\n\n\n\n\n\n\nfilter_checkbox_deniv = (lang == \"fr\") ? \"D√©nivel√©\" : \"Height gain\"\nfilter_checkbox_category = (lang == \"fr\") ? \"Cat√©gorie de l'ascension\" : \"Ascent category\"\nfilter_checkbox_length = (lang == \"fr\") ? `Longueur de l'ascension` : \"Ascension length\"\nfilter_checkbox_slope = (lang == \"fr\") ? \"Pente moyenne\" : \"Average slope\"\nfilter_multiselect_group = (lang == \"fr\") ? \"Massif de l'ascension\" : \"Mountain chain\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlabel_search_widget = (lang == \"fr\") ? \"Rechercher un col\" : \"Finding an ascent\"\n\n\n\n\n\n\n\n\nlabel_find_adress = (lang == \"fr\") ?\n  \"1Ô∏è‚É£ Taper une adresse ou une localisation dans la barre de recherche üëáÔ∏è\" :\n  \"1Ô∏è‚É£ Search for a location below üëáÔ∏è\"\n\n\n\n\n\n\n\n\nfunction availableLayers(L, map){\n  \n  // Define tile layers\n  var defaultLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    maxZoom: 19,\n    attribution: '¬© OpenStreetMap contributors'\n  }).addTo(map); // Set as the default layer\n  \n  var topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {\n    maxZoom: 17,\n    attribution: '¬© OpenStreetMap contributors, ¬© OpenTopoMap (CC-BY-SA)'\n  });\n  \n  var cycleLayer = L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {\n    maxZoom: 20,\n    attribution: '¬© OpenStreetMap contributors, ¬© CyclOSM'\n  });\n  \n  // Add the base layers to a layer control\n  var baseLayers = {\n    \"Default\": defaultLayer,\n    \"Topographic\": topoLayer,\n    \"Cycling\": cycleLayer\n  };\n\n  return baseLayers  \n}\n\n\n\n\n\n\n\n\nwhenClicked =  (event) =&gt; {\n  mutable selectedClimb = event.target.feature.properties\n  }\n\n\n\n\n\n\n\nfunction featureEvents(feature, layer) {\n   layer.on({\n     click: whenClicked, //callback functions\n   });\n}\n\n\n\n\n\n\n\nfunction fetchAndDisplayAscentRoute(map, feature, color = 'green') {\n  const id = feature.properties.id;\n  const polylineUrl = `https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/split/${id}.geojson`;\n\n  fetch(polylineUrl)\n    .then(response =&gt; response.json())\n    .then(data =&gt; {\n      // Modify the ascentTrackPolyline function or create a similar one to accept a color parameter\n      ascentTrackPolyline(map, data, feature, color);\n    })\n    .catch(error =&gt; console.error('Error loading the polyline GeoJSON:', error));\n}\n\n\n\n\n\n\n\n\nfunction createIcon(feature, coordinates, color = null){\n        const color_value = (color == null) ? getColorForCategory(feature.properties.category) : color ;\n        const iconUrl = `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color_value}.png`;\n                \n        var icon_color = new L.Icon({\n          iconUrl: iconUrl,\n          shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',\n          iconSize: [25, 41],\n          iconAnchor: [12, 41],\n          popupAnchor: [1, -34],\n          shadowSize: [41, 41]\n        });\n        \n        return L.marker(coordinates, {icon: icon_color})\n\n}\n\n\n\n\n\n\n\nfunction getColorForCategory(category) {\n  switch (category) {\n    case 'Cat 1':\n      return 'blue';\n    case 'Cat 2':\n      return 'green';\n    case 'Cat 3':\n      return 'yellow';\n    case 'Cat 4':\n      return 'orange';\n    case 'HC':\n      return 'red';\n    default:\n      return 'gray';\n  }\n}\n\n\n\n\n\n\n\nfunction ascentTrackPolyline(map, data, feature, color){\n            // Create a polyline from the GeoJSON and add it to the map\n            const polyline = L.geoJson(data, {\n              color: color, // You can customize the polyline's style here\n              weight: 3\n            }).addTo(map);\n\n            // Mouseover for ascent characteristics \n            polyline.on('mouseover', function() {\n              this.bindTooltip(\n                 tooltipRoute(feature),\n                {permanent: false, direction: \"top\"}).openTooltip();\n              \n            });\n\n            // Get mouse location on the map to interactively update a figure\n            const points = toGeoJSONFeatureCollection(data);\n            \n            // polyline.on('mousemove', function(e) {\n              // var nearest = get_nearest_point(e, points)\n              // Update the mutable hover_alt to the altitude\n              // mutable hover_alt = nearest;\n            // });\n\n  return polyline\n}\n\n\n\n\n\n\n\n\nfunction popUpSummit(feature, lang){\n  const AscentName = (lang == \"fr\") ? \"Ascension\" : \"Ascent\" ;\n  const departure = (lang == \"fr\") ? \"D√©part\" : \"Start\" ;\n  const maxAlt = (lang == \"fr\") ? \"Sommet\" : \"Summit\" ;\n  const climbLength = (lang == \"fr\") ? \"Longueur\" : \"Length\" ;\n  const gain = (lang == \"fr\") ? \"D√©nivel√©\" : \"Gain\" ;\n  const averageSlope = (lang == \"fr\") ? \"Pente moyenne\" : \"Average slope\" ; \n  const maxSlope = (lang == \"fr\") ? \"Pente maximale\" : \"Maximum slope\" ; \n  const hrefText =  (lang == \"fr\") ? \"Voir sur\" : \"See on\"\n  const popup = `\n          &lt;b&gt;${AscentName}&lt;/b&gt;: ${feature.properties.nom}&lt;br&gt;\n          &lt;b&gt;${departure}&lt;/b&gt;: ${feature.properties.depart} (${feature.properties.massif})&lt;br&gt; \n          &lt;b&gt;${maxAlt}&lt;/b&gt;: ${feature.properties.alt}m&lt;br&gt;\n          &lt;b&gt;${climbLength}&lt;/b&gt;: ${feature.properties.longueur}km&lt;br&gt;\n          &lt;b&gt;${gain}&lt;/b&gt;: ${feature.properties.denivellation}m (${feature.properties.category})&lt;br&gt;\n          &lt;b&gt;${averageSlope}&lt;/b&gt;: ${feature.properties.percent_moyen}%&lt;br&gt;\n          &lt;b&gt;${maxSlope}&lt;/b&gt;: ${feature.properties.percent_maximal}%&lt;br&gt;\n          &lt;a href=\"${feature.properties.href}\" target=\"_blank\"&gt;${hrefText} &lt;code&gt;https://cols-cyclisme.com/&lt;/code&gt;&lt;/a&gt;\n` \n  return popup\n\n}\n\n\n\n\n\n\n\n\nfunction tooltipSummit(feature){\n  const tooltipMessage = `&lt;b&gt;${feature.properties.nom}&lt;/b&gt;&lt;br&gt;&lt;i&gt;${label_click_map}&lt;/i&gt;`\n  return tooltipMessage\n}\n\n\n\n\n\n\n\nfunction tooltipRoute(feature){\n  const departure = (lang == \"fr\") ? \"D√©part de\" : \"Start from\" ;\n  const maxAlt = (lang == \"fr\") ? \"altitude d'arriv√©e:\" : \"summit at\" ;\n  const climbLength = (lang == \"fr\") ? \"Ascension de\" : \"Climbing length is\" ;\n  const averageSlope = (lang == \"fr\") ? \"de moyenne\" : \"on average\" ; \n  const denivelle = (lang == \"fr\") ? \"D+\" : \"gain\" ; \n  const maxSlope = (lang == \"fr\") ? \"Pente maximale\" : \"Maximum slope\" ; \n\n  const popup = `\n                  &lt;b&gt;${feature.properties.nom}&lt;/b&gt;&lt;br&gt;\n                  ${departure} ${feature.properties.depart} (${maxAlt} ${feature.properties.altitude}m)&lt;br&gt;\n                  ${climbLength} ${feature.properties.longueur}km, ${feature.properties.percent_moyen}% ${averageSlope} (${feature.properties.denivellation}m ${denivelle})&lt;br&gt;\n                  &lt;i&gt;${maxSlope}:  ${feature.properties.percent_maximal}%&lt;/i&gt;\n  `\n  return popup\n}\n\n\n\n\n\n\n\nfunction container_ascent(feature, lang, width){\n\n  const imageInitial = feature.properties.profil_image_url ;\n\n  const imageURL = imageInitial.replace(\n          'profils.cols-cyclisme.com',\n          'minio.lab.sspcloud.fr/lgaliana/cyclisme/data/images'\n        ) ;\n\n  let container ;\n\n  if (width &gt; 400){\n    container = `\n      &lt;div id=\"container-statistics\" style=\"display: flex; flex-direction: column;\"&gt;\n        &lt;div style=\"display: flex; justify-content: space-between; align-items: flex-start; width: 100%;\"&gt;\n          &lt;div style=\"width: 20%;\"&gt;\n            ${popUpSummit(feature, lang, width &gt; 400)}\n          &lt;/div&gt;\n          &lt;div id=\"ascent-image\" style=\"width: 80%;\"&gt;\n            &lt;img src=\"${imageURL}\" alt=\"\" style=\"max-width: 100%; height: auto; max-height:${screenHeight*0.5};\"&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div id=\"stats-denivellation\" style=\"width: 100%;\"&gt;\n          &lt;!-- Content for stats-denivellation goes here --&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n          ` ;\n  } else{\n    container = `\n      &lt;div id=\"container-statistics\" style=\"display: flex; flex-direction: column;\"&gt;\n          &lt;div style=\"width: 100%;\"&gt;\n            ${popUpSummit(feature, lang, width &gt; 400)}\n          &lt;/div&gt;\n        &lt;div id=\"stats-denivellation\" style=\"width: 100%;\"&gt;\n          &lt;!-- Content for stats-denivellation goes here --&gt;\n        &lt;/div&gt;\n          &lt;div id=\"ascent-image\" style=\"width: 80%;\"&gt;\n            &lt;img src=\"${imageURL}\" alt=\"\" style=\"max-width: 100%; height: auto; max-height:${screenHeight*0.5};\"&gt;\n          &lt;/div&gt;\n      &lt;/div&gt;\n    `\n  }\n\n  return container\n}\n\n\n\n\n\n\n\nL.GeocoderBAN = L.Control.extend({\n        options: {\n            position: 'topleft',\n            style: 'control',\n            placeholder: 'adresse',\n            resultsNumber: 7,\n            collapsed: true,\n            serviceUrl: 'https://api-adresse.data.gouv.fr/search/',\n            minIntervalBetweenRequests: 250,\n            defaultMarkgeocode: true,\n            autofocus: true\n        },\n        includes: L.Evented.prototype || L.Mixin.Events,\n        initialize: function (options) {\n            L.Util.setOptions(this, options);\n        },\n        onRemove: function (map) {\n            map.off('click', this.collapseHack, this);\n        },\n        onAdd: function (map) {\n            var className = 'leaflet-control-geocoder-ban';\n            var container = this.container = L.DomUtil.create('div', className + ' leaflet-bar');\n            var icon = this.icon = L.DomUtil.create('button', className + '-icon', container);\n            var form = this.form = L.DomUtil.create('div', className + '-form', container);\n            var input;\n            \n            map.on('click', this.collapseHack, this);\n            \n            icon.innerHTML = '&nbsp;';\n            icon.type = 'button';\n            \n            input = this.input = L.DomUtil.create('input', '', form);\n            input.type = 'text';\n            input.placeholder = this.options.placeholder;\n            \n            this.alts = L.DomUtil.create('ul',\n            className + '-alternatives ' + className + '-alternatives-minimized',\n            container);\n            \n            L.DomEvent.on(icon, 'click', function (e) {\n                this.toggle();\n                L.DomEvent.preventDefault(e);\n            }, this);\n            L.DomEvent.addListener(input, 'keyup', this.keyup, this);\n            \n            L.DomEvent.disableScrollPropagation(container);\n            L.DomEvent.disableClickPropagation(container);\n            \n            if (!this.options.collapsed) {\n                this.expand();\n                if (this.options.autofocus) {\n                    setTimeout(function () { input.focus(); }, 250);\n                }\n            }\n            if (this.options.style === 'searchBar') {\n                L.DomUtil.addClass(container, 'searchBar');\n                var rootEl = document.getElementsByClassName('leaflet-control-container')[0];\n                rootEl.appendChild(container);\n                return L.DomUtil.create('div', 'hidden');\n            } else {\n                return container;\n            }\n        },\n        minimizeControl: function () {\n            if (this.options.style === 'control') {\n                this.collapse();\n            } else {\n                // for the searchBar: only hide results, not the bar\n                L.DomUtil.addClass(this.alts, 'leaflet-control-geocoder-ban-alternatives-minimized');\n            }\n        },\n        toggle: function () {\n            if (this.style != 'searchBar') {\n                if (L.DomUtil.hasClass(this.container, 'leaflet-control-geocoder-ban-expanded')) {\n                    this.collapse();\n                } else {\n                    this.expand();\n                }\n            }\n        },\n        expand: function () {\n            L.DomUtil.addClass(this.container, 'leaflet-control-geocoder-ban-expanded');\n            if (this.geocodeMarker) {\n                this._map.removeLayer(this.geocodeMarker);\n            }\n            this.input.select();\n        },\n        collapse: function () {\n            L.DomUtil.removeClass(this.container, 'leaflet-control-geocoder-ban-expanded');\n            L.DomUtil.addClass(this.alts, 'leaflet-control-geocoder-ban-alternatives-minimized');\n            this.input.blur();\n        },\n        collapseHack: function (e) {\n            // leaflet bug (see #5507) before v1.1.0 that converted enter keypress to click.\n            if (e.originalEvent instanceof MouseEvent) {\n                this.minimizeControl();\n            }\n        },\n        moveSelection: function (direction) {\n            var s = document.getElementsByClassName('leaflet-control-geocoder-ban-selected');\n            var el;\n            if (!s.length) {\n                el = this.alts[direction &lt; 0 ? 'firstChild' : 'lastChild'];\n                L.DomUtil.addClass(el, 'leaflet-control-geocoder-ban-selected');\n            } else {\n                var currentSelection = s[0];\n                L.DomUtil.removeClass(currentSelection, 'leaflet-control-geocoder-ban-selected');\n                if (direction &gt; 0) {\n                    el = currentSelection.previousElementSibling ? currentSelection.previousElementSibling : this.alts['lastChild'];\n                } else {\n                    el = currentSelection.nextElementSibling ? currentSelection.nextElementSibling : this.alts['firstChild'];\n                }\n            }\n            if (el) {\n                L.DomUtil.addClass(el, 'leaflet-control-geocoder-ban-selected');\n            }\n        },\n        keyup: function (e) {\n            switch (e.keyCode) {\n                case 27:\n                    // escape\n                    this.minimizeControl();\n                    L.DomEvent.preventDefault(e);\n                    break;\n                case 38:\n                    // down\n                    this.moveSelection(1);\n                    L.DomEvent.preventDefault(e);\n                    break;\n                case 40:\n                    // up\n                    this.moveSelection(-1);\n                    L.DomEvent.preventDefault(e);\n                    break;\n                case 13:\n                    // enter\n                    var s = document.getElementsByClassName('leaflet-control-geocoder-ban-selected');\n                    if (s.length) {\n                        this.geocodeResult(s[0].geocodedFeatures);\n                    }\n                    L.DomEvent.preventDefault(e);\n                    break;\n                default:\n                    if (this.input.value) {\n                        var params = {q: this.input.value, limit: this.options.resultsNumber};\n                        var t = this;\n                        if (this.setTimeout) {\n                            clearTimeout(this.setTimeout);\n                        }\n                        // avoid responses collision if typing quickly\n                        this.setTimeout = setTimeout(function () {\n                            getJSON(t.options.serviceUrl, params, t.displayResults(t));\n                        }, this.options.minIntervalBetweenRequests);\n                    } else {\n                        this.clearResults();\n                    }\n                    L.DomEvent.preventDefault(e);\n            }\n        },\n        clearResults: function () {\n            while (this.alts.firstChild) {\n                this.alts.removeChild(this.alts.firstChild);\n            }\n        },\n        displayResults: function (t) {\n            t.clearResults();\n            return function (res) {\n                if (res && res.features) {\n                    var features = res.features;\n                    L.DomUtil.removeClass(t.alts, 'leaflet-control-geocoder-ban-alternatives-minimized');\n                    for (var i = 0; i &lt; Math.min(features.length, t.options.resultsNumber); i++) {\n                        t.alts.appendChild(t.createAlt(features[i], i));\n                    }\n                }\n            };\n        },\n        createAlt: function (feature, index) {\n            var li = L.DomUtil.create('li', '');\n            var a = L.DomUtil.create('a', '', li);\n            li.setAttribute('data-result-index', index);\n            a.innerHTML = '&lt;strong&gt;' + feature.properties.label + '&lt;/strong&gt;, ' + feature.properties.context;\n            li.geocodedFeatures = feature;\n            var clickHandler = function (e) {\n                this.minimizeControl();\n                this.geocodeResult(feature);\n            };\n            var mouseOverHandler = function (e) {\n                var s = document.getElementsByClassName('leaflet-control-geocoder-ban-selected');\n                if (s.length) {\n                    L.DomUtil.removeClass(s[0], 'leaflet-control-geocoder-ban-selected');\n                }\n                L.DomUtil.addClass(li, 'leaflet-control-geocoder-ban-selected');\n            };\n            var mouseOutHandler = function (e) {\n                L.DomUtil.removeClass(li, 'leaflet-control-geocoder-ban-selected');\n            };\n            L.DomEvent.on(li, 'click', clickHandler, this);\n            L.DomEvent.on(li, 'mouseover', mouseOverHandler, this);\n            L.DomEvent.on(li, 'mouseout', mouseOutHandler, this);\n            return li;\n        },\n        geocodeResult: function (feature) {\n            this.minimizeControl();\n            this.markGeocode(feature);\n        },\n        markGeocode: function (feature) {\n            var latlng = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]];\n            this._map.setView(latlng, 14);\n            this.geocodeMarker = new L.Marker(latlng)\n                .bindPopup(feature.properties.label)\n                .addTo(this._map)\n                .openPopup();\n        }\n    });\n\n\n\n\n\n\n\ngetJSON = function (url, params, callback) {\n  var xmlHttp = new XMLHttpRequest()\n  xmlHttp.onreadystatechange = function () {\n    if (xmlHttp.readyState !== 4) {\n      return\n    }\n    if (xmlHttp.status !== 200 && xmlHttp.status !== 304) {\n      return\n    }\n    callback(JSON.parse(xmlHttp.response))\n  }\n  xmlHttp.open('GET', url + L.Util.getParamString(params), true)\n  xmlHttp.setRequestHeader('Accept', 'application/json')\n  xmlHttp.send(null)\n}\n\n\n\n\n\n\n\nL.geocoderBAN = function (options) {\n    return new L.GeocoderBAN(options)\n}\n\n\n\n\n\n\n\nviewof radiusInner = Inputs.range([0, 100], {value: 20})\n\n\n\n\n\n\n\nradius = Inputs.bind(\n          Range([1, 100], {unit: \"km\", value: 20, step: 1}),\n          viewof radiusInner\n)\n\n\n\n\n\n\n\n\ntable_selected = Inputs.table(\n  search,\n  {\n    columns: [\n      \"nom\",\n      \"depart\",\n      \"longueur\",\n      \"denivellation\",\n      \"altitude\",\n      \"percent_moyen\",\n      \"percent_maximal\"\n    ],\n    header: {\n        nom: header_table_name,\n        depart: header_table_departure,\n        longueur: filter_checkbox_length,\n        denivellation: filter_checkbox_deniv,\n        altitude: header_table_alt,\n        percent_moyen: header_table_avgpercent,\n        percent_maximal: header_table_maxpercent\n      },\n    sort: \"denivellation\", reverse: true\n})\n\n\n\n\n\n\n\nhelp_page2 = {\n  if (selectlatlng == null){\n    return label_find_adress\n  }\n  return html`&lt;div&gt;${label_choose_radius}&lt;/div&gt;&lt;div class=\"radius-selector\"&gt;${radius}&lt;/div&gt;`\n}\n\n\n\n\n\n\n\nfunction messageRadius(foundfeatures){\n  if (foundfeatures == null){\n    return null\n  }\n  const message = (lang == \"fr\") ?\n  `2Ô∏è‚É£ Choisissez un rayon autour de &lt;span class=\"foundplace\"&gt;${foundfeatures.properties.label}&lt;/span&gt; puis explorez la carte üëáÔ∏è` :\n  `2Ô∏è‚É£ Choose a radius size around &lt;span class=\"foundplace\"&gt;${foundfeatures.properties.label}&lt;/span&gt; and explore the map üëáÔ∏è`\n  return message\n}\n\n\n\n\n\n\n\nlabel_choose_radius = messageRadius(foundfeatures)\n\n\n\n\n\n\n\nhtml\n`\n&lt;div class=\"lang-selector\"&gt;${viewof lang}&lt;/div&gt;\n&lt;div class=\"container\"&gt;\n  &lt;div class=\"message-input-select\"&gt;${help_page2}&lt;/div&gt;\n&lt;div/&gt;\n`\n\n\n\n\n\n\n\nsearch = (aroundClimb == null) ? cols : aroundClimb.features.map(d =&gt; d.properties)\n\n\n\n\n\n\n\nmessage_climb_radius = function(aroundClimb){\n\n  if (aroundClimb == null){\n    return ``\n  }\n\n  const message = (lang == \"fr\") ?\n    html`${search.features.length} ascensions dans un rayon de ${radius} km` :\n    html`${search.features.length} climb in a ${radius} km radius` ;\n\n  return message \n\n}\n\n\n\n\n\n\n\n(width &gt; 400) ?\n  html`\n  &lt;div class=\"main-container\"&gt;\n    &lt;div id = \"leafletmap\" style=\"width: 40%;\"&gt;${leafletmap}&lt;/div&gt;\n    &lt;div class=\"column spacer\" style=\"width: 2%;\"&gt;\n        &lt;!-- Spacer column --&gt;\n    &lt;/div&gt;\n    &lt;div style=\"width: 58%;\"&gt;\n      &lt;div id=\"available-ascent\"&gt;\n      &lt;div&gt;&lt;i&gt;${finding_ascent_label}&lt;/i&gt;&lt;/div&gt;\n      &lt;br&gt;\n      ${table_selected}\n      &lt;br&gt;\n      &lt;/div&gt;\n    &lt;div id=\"statsElement\"&gt;&lt;i&gt;${no_ascent_label}&lt;/i&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  ` :\n  html`\n    &lt;div id = \"leafletmap\" style=\"width: 100%;\"&gt;${leafletmap}&lt;/div&gt;\n    &lt;div style=\"width: 100%;\"&gt;\n      &lt;div id=\"available-ascent\"&gt;\n      &lt;div&gt;&lt;i&gt;${finding_ascent_label}&lt;/i&gt;&lt;/div&gt;\n      &lt;br&gt;\n      ${table_selected}\n      &lt;br&gt;\n      &lt;/div&gt;\n    &lt;div id=\"statsElement\"&gt;&lt;i&gt;${no_ascent_label}&lt;/i&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  `\n\n\n\n\n\n\n\nfunction addGeoJSONToMap(geoJSON, map, pointsWithin) {\n    L.geoJSON(geoJSON, {\n        style: function(feature) {\n            // Define the style of the polyline here if needed\n            return { color: feature.properties.stroke || 'blue', weight: 4 };\n        },\n        onEachFeature: function(feature, layer) {\n            const id = feature.properties.url.replace(\".gpx\", '') ;\n            const summit_info = geo.filter(pointsWithin, (d) =&gt; d.id == id)\n            let selectedLayer = null;\n\n            layer.bindTooltip(\n              tooltipSummit(\n                summit_info.features[0]\n              ),\n                {permanent: false, direction: 'auto'}\n            );\n\n            layer.bindPopup(\n              popUpSummit(summit_info.features[0], lang)\n            );\n\n            layer.on({\n              click: (event) =&gt; {\n                if (selectedLayer && selectedLayer != layer) {\n                      selectedLayer.setStyle({\n                        color: selectedLayer.feature.properties.stroke || 'blue', // Reset to original color\n                        weight: 4 // Reset to original weight\n                      });\n                    }\n                mutable selectedClimb = summit_info.features[0] ;\n                // Set the clicked layer as the new selected layer\n                selectedLayer = layer; \n                layer.setStyle({\n                        color: 'red', // Set color to red for the selected polyline\n                        weight: 4\n                    });               \n              },\n            });\n\n            // Existing event listener for popup opens\n            layer.on('popupopen', function() {\n              const statsElement = document.getElementById('statsElement');\n              const availableAscents = document.getElementById('available-ascent');        \n              \n              // Update the content of 'statsElement' with the desired statistics from 'feature.properties'\n              statsElement.innerHTML = container_ascent(summit_info.features[0], lang, width) ;\n              availableAscents.innerHTML = \"\" ;\n\n              // Fetch route for selected ascent\n              fetchAndDisplayAscentRoute(map, summit_info.features[0], 'red');\n            });\n\n\n            layer.on('click', function() {\n                this.setStyle({\n                    color: 'red', // Change polyline color on mouseover\n                    weight: 4 // Increase polyline weight on mouseover\n                });\n            });\n            layer.on('mouseover', function() {\n              if (layer !== selectedLayer) {\n                this.setStyle({\n                    color: 'yellow', // Change polyline color on mouseover\n                    weight: 6 // Increase polyline weight on mouseover\n                });\n              }\n            });\n            layer.on('mouseout', function() {\n              if (layer !== selectedLayer) {\n                this.setStyle({\n                    color: feature.properties.stroke || 'blue', // Reset color\n                    weight: 2 // Reset weight\n                });\n              }\n            });\n        }\n    }).addTo(map);\n}\n\n\n\n\n\n\n\n\n\nmutable foundfeatures = null ;\n\n\n\n\n\n\n\nfunction getPointsWithinCircle(centerCircle, sommets){\n\n    var options = {steps: 64, units: 'kilometers'};\n    var circle = turf.circle(\n      centerCircle , radiusInner, options\n    );\n    // Perform spatial query with Turf.js using the drawn circle\n    var pointsWithin = turf.pointsWithinPolygon(sommets, circle);\n\n    return pointsWithin    \n  }\n\n\n\n\n\n\n\nconsole.log(foundfeatures)\n\n\n\n\n\n\n\nleafletmap = {\n\n  // Create a container element for leaflet map\n  let parent = DOM.element('div', { style: `width:${mapWidth}px;height:${mapHeight}px` });\n  yield parent;\n  var map = L.map(parent).setView([45.853459, 2.349312], 5);\n\n  const baseUrl = 'https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/split';\n  var radiustemp = radius ;\n\n  // Add the layer control to the map\n  let baseLayers = availableLayers(L, map) ;\n  L.control.layers(baseLayers).addTo(map);\n\n\n  var geocoder = L.geocoderBAN({\n    collapsed: false, style: 'searchBar'\n    }).addTo(map)\n\n  geocoder.markGeocode = function(feature) {\n    var latlng = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]]\n    map.setView(latlng, 8)\n    mutable selectlatlng = latlng;\n    mutable foundfeatures = feature ;\n  }\n\n  if (selectlatlng != null){\n\n    console.log(selectlatlng)\n\n    // Center of the circle\n    var foundpoint = createIcon(\n      null, selectlatlng, \"black\"\n    ).addTo(map);\n    foundpoint.bindPopup(foundfeatures.properties.label).openPopup() ;\n    // Circle\n    var circle = L.circle(selectlatlng, { radius: radiusInner*1000 }).addTo(map);\n    map.fitBounds(circle.getBounds())\n\n    // Detect points within circle\n    const pointsWithin = getPointsWithinCircle(selectlatlng.reverse(), sommets) ;\n    mutable aroundClimb = pointsWithin\n\n    // Add rot\n\n    // Add summit markers\n    var geojsonLayer = L.geoJson(\n        pointsWithin, {\n          onEachFeature: popEventSummit,\n          pointToLayer: function(feature, coordinates) {\n            return createIcon(feature, coordinates)        \n        }\n    }).addTo(map);\n\n\n    // Add ascent routes tracks\n    const ids = pointsWithin.features.map(d=&gt; d.properties.id) ;\n    getCombinedGeoJSON(ids, baseUrl)\n    .then(combinedGeoJSON =&gt; {\n        // Add each feature from the combined GeoJSON as a separate polyline\n        combinedGeoJSON.features.forEach((feature) =&gt; {\n            addGeoJSONToMap(feature, map, pointsWithin);\n        });\n    })\n    .catch(error =&gt; {\n        console.error('An error occurred:', error);\n    });\n\n    }\n\n  // Define a function that will be called for each feature in your GeoJSON layer\n  function popEventSummit(feature, layer) {\n\n      // Add mouseover event listener\n      layer.on('mouseover', function() {\n        const tooltipMessage = tooltipSummit(feature) ;\n        layer.bindTooltip(\n          tooltipMessage, {permanent: false, direction: \"auto\"}\n          ).openTooltip();\n      });\n\n      // Create popup for ascent summit\n      layer.bindPopup(\n        popUpSummit(feature, lang)\n      );\n\n     layer.on({\n       click: whenClicked, //callback functions\n     });\n      \n      // Existing event listener for popup opens\n      layer.on('popupopen', function() {\n        const statsElement = document.getElementById('statsElement');\n        const availableAscents = document.getElementById('available-ascent');        \n        \n        // Update the content of 'statsElement' with the desired statistics from 'feature.properties'\n        statsElement.innerHTML = container_ascent(feature, lang, width) ;\n        availableAscents.innerHTML = \"\" ;\n\n        // Fetch route for selected ascent\n        fetchAndDisplayAscentRoute(map, feature, 'red');\n      });\n\n  }\n\n}\n\n\n\n\n\n\n\nmutable selectlatlng = null\n\n\n\n\n\n\n\nmutable selectedClimb = null ;\n\n\n\n\n\n\n\nmutable aroundClimb = null\n\n\n\n\n\n\n\n{\n  document.querySelector('#stats-denivellation').appendChild(\n    rank_ascent(sommets, \"denivellation\", selectedClimb, lang)\n  )\n  document.querySelector('#stats-denivellation').appendChild(\n    rank_ascent(sommets, \"longueur\", selectedClimb, lang)\n  )\n\n}"
  }
]