---
title: "Quelles sont les ascensions autour de moi?"
echo: false
---

{{< include /common/_data.qmd >}}
{{< include /common/_globals.qmd >}}
{{< include /common/_inputs.qmd >}}
{{< include /common/_labels.qmd >}}
{{< include /common/_leaflet_functions.qmd >}}
{{< include /common/_leaflet_ban.qmd >}}



```{ojs}
viewof lang = startStop()
```

```{ojs}
mutable selectedClimb = null ;
```

```{ojs}
//| output: true
radius = Inputs.bind(
          Range([1, 100], {unit: "km", value: 20, step: 1}),
          viewof radiusInner
)
```

```{ojs}
//| output: false
viewof radiusInner = Inputs.range([0, 100], {value: 20}) 
```


```{ojs}
table_selected = Inputs.table(
  cols,
  {
    columns: [
      "nom",
      "depart",
      "longueur",
      "denivellation",
      "altitude",
      "percent_moyen",
      "percent_maximal"
    ],
    header: {
        nom: header_table_name,
        depart: header_table_departure,
        longueur: filter_checkbox_length,
        denivellation: filter_checkbox_deniv,
        altitude: header_table_alt,
        percent_moyen: header_table_avgpercent,
        percent_maximal: header_table_maxpercent
      },
    sort: "denivellation", reverse: true
})
```


```{ojs}
//| output: true
(width > 400) ?
  html`
  <div class="main-container">
    <div id = "leafletmap" style="width: 40%;">${leafletmap}</div>
    <div class="column spacer" style="width: 2%;">
        <!-- Spacer column -->
    </div>
    <div style="width: 58%;">
      <div id="available-ascent">
      <div><i>${finding_ascent_label}</i></div>
      <br>
      ${table_selected}
      <br>
      </div>
    <div id="statsElement"><i>${no_ascent_label}</i></div>
    </div>
  </div>
  ` :
  html`
    <div id = "leafletmap" style="width: 100%;">${leafletmap}</div>
    <div style="width: 100%;">
      <div id="available-ascent">
      <div><i>${finding_ascent_label}</i></div>
      <br>
      ${table_selected}
      <br>
      </div>
    <div id="statsElement"><i>${no_ascent_label}</i></div>
    </div>
  `
```


```{ojs}
mutable selectlatlng = null
```

```{ojs}
//| output: true
//| echo: true
selectlatlng
```

```{ojs}
//| output: true
//| echo: true
aroundClimb
```

```{ojs} 
//| eval: false
L.AwesomeMarkers = {};
```

```{ojs}      
//| eval: false  
L.AwesomeMarkers.version = '2.0.1';
```



```{ojs}        
L.AwesomeMarkersInner = L.Icon.extend({
    options: {
        iconSize: [35, 45],
        iconAnchor: [17, 42],
        popupAnchor: [1, -32],
        shadowAnchor: [10, 12],
        shadowSize: [36, 16],
        className: 'awesome-marker',
        prefix: 'glyphicon',
        spinClass: 'fa-spin',
        extraClasses: '',
        icon: 'home',
        markerColor: 'blue',
        iconColor: 'white'
    },

    initialize: function (options) {
        options = L.Util.setOptions(this, options);
    },

    createIcon: function () {
        var div = document.createElement('div'),
            options = this.options;

        if (options.icon) {
            div.innerHTML = this._createInner();
        }

        if (options.bgPos) {
            div.style.backgroundPosition =
                (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
        }

        this._setIconStyles(div, 'icon-' + options.markerColor);
        return div;
    },

    _createInner: function () {
        var iconClass, iconSpinClass = "", iconColorClass = "", iconColorStyle = "", options = this.options;

        if (options.icon.slice(0, options.prefix.length + 1) === options.prefix + "-") {
            iconClass = options.icon;
        } else {
            iconClass = options.prefix + "-" + options.icon;
        }

        if (options.spin && typeof options.spinClass === "string") {
            iconSpinClass = options.spinClass;
        }

        if (options.iconColor) {
            if (options.iconColor === 'white' || options.iconColor === 'black') {
                iconColorClass = "icon-" + options.iconColor;
            } else {
                iconColorStyle = "style='color: " + options.iconColor + "' ";
            }
        }

        return "<i " + iconColorStyle + "class='" + options.extraClasses + " " + options.prefix + " " + iconClass + " " + iconSpinClass + " " + iconColorClass + "'></i>";
    },

    _setIconStyles: function (img, name) {
        var options = this.options,
            size = L.point(options[name === 'shadow' ? 'shadowSize' : 'iconSize']),
            anchor;

        if (name === 'shadow') {
            anchor = L.point(options.shadowAnchor || options.iconAnchor);
        } else {
            anchor = L.point(options.iconAnchor);
        }

        if (!anchor && size) {
            anchor = size.divideBy(2, true);
        }

        img.className = 'awesome-marker-' + name + ' ' + options.className;

        if (anchor) {
            img.style.marginLeft = (-anchor.x) + 'px';
            img.style.marginTop = (-anchor.y) + 'px';
        }

        if (size) {
            img.style.width = size.x + 'px';
            img.style.height = size.y + 'px';
        }
    },

    createShadow: function () {
        var div = document.createElement('div');

        this._setIconStyles(div, 'shadow');
        return div;
    }
});
```

```{ojs}
L.AwesomeMarkers = function (options) {
    return new L.AwesomeMarkersInner(options);
};
```

```{=html}
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.css" rel="stylesheet">
<link rel="stylesheet" href="https://raw.githubusercontent.com/lennardv2/Leaflet.awesome-markers/2.0/develop/dist/leaflet.awesome-markers.css">
```

```{ojs}
mutable foundfeatures = null ;
```


```{ojs}
leafletmap = {

  // Create a container element for leaflet map
  let parent = DOM.element('div', { style: `width:${mapWidth}px;height:${mapHeight}px` });
  yield parent;
  var map = L.map(parent).setView([45.853459, 2.349312], 5);

  var radiustemp = radius ;

  // Add the layer control to the map
  let baseLayers = availableLayers(L, map) ;
  L.control.layers(baseLayers).addTo(map);


  var geocoder = L.geocoderBAN({
    collapsed: false, style: 'searchBar'
    }).addTo(map)

  geocoder.markGeocode = function(feature) {
    var latlng = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]]
    map.setView(latlng, 8)

    mutable selectlatlng = latlng;
    mutable foundfeatures = feature ;

    console.log(feature)

  }

  if (selectlatlng != null){
    console.log(selectlatlng)

  var foundpoint = createIcon(
    null, selectlatlng, "black"
  ).addTo(map);
  
  foundpoint.bindPopup(foundfeatures.properties.label).openPopup() ;

    var circle = L.circle(selectlatlng, { radius: radiusInner*1000 }).addTo(map);
    map.fitBounds(circle.getBounds())

    console.log(radiusInner)

    var options = {steps: 64, units: 'kilometers'};
    var circle = turf.circle(
      selectlatlng.reverse(), radiusInner, options
    );

    // Perform spatial query with Turf.js using the drawn circle
    var pointsWithin = turf.pointsWithinPolygon(sommets, circle);

    console.log(pointsWithin)

    mutable aroundClimb = pointsWithin

    var geojsonLayer = L.geoJson(
        pointsWithin, {
          onEachFeature: popEventSummit,
          pointToLayer: function(feature, coordinates) {
            return createIcon(feature, coordinates)        
        }
    }).addTo(map);

  }

  // Define a function that will be called for each feature in your GeoJSON layer
  function popEventSummit(feature, layer) {

      // Add mouseover event listener
      //layer.on('mouseover', function() {
      //  const tooltipMessage = tooltipSummit(feature) ;
      //  layer.bindTooltip(
      //    tooltipMessage, {permanent: false, direction: "auto"}
      //    ).openTooltip();
      //});

      // Create popup for ascent summit
      //layer.bindPopup(
        //popUpSummit(feature, lang)
      //);

     layer.on({
       click: whenClicked, //callback functions
     });
      
      // Existing event listener for popup opens
      layer.on('popupopen', function() {
        const statsElement = document.getElementById('statsElement');
        const availableAscents = document.getElementById('available-ascent');        
        
        // Update the content of 'statsElement' with the desired statistics from 'feature.properties'
        //statsElement.innerHTML = container_ascent(feature, lang, width) ;
        //availableAscents.innerHTML = "" ;

        // Fetch route for selected ascent
        // fetchAndDisplayAscentRoute(map, feature, 'red');
      });

  }

}
```


```{ojs}
//| output: true
mutable aroundClimb = null
```