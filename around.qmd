---
title: "Quelles sont les ascensions autour de moi?"
echo: false
---

{{< include /common/_data.qmd >}}
{{< include /common/_globals.qmd >}}
{{< include /common/_inputs.qmd >}}
{{< include /common/_labels.qmd >}}
{{< include /common/_leaflet_functions.qmd >}}
{{< include /common/_leaflet_ban.qmd >}}



```{ojs}
viewof lang = startStop()
```

```{ojs}
mutable selectedClimb = null ;
```

```{ojs}
//| output: true
radius = Inputs.bind(
          Range([1, 100], {unit: "km", value: 20, step: 1}),
          viewof radiusInner
)
```

```{ojs}
//| output: false
viewof radiusInner = Inputs.range([0, 100], {value: 20}) 
```


```{ojs}
table_selected = Inputs.table(
  cols,
  {
    columns: [
      "nom",
      "depart",
      "longueur",
      "denivellation",
      "altitude",
      "percent_moyen",
      "percent_maximal"
    ],
    header: {
        nom: header_table_name,
        depart: header_table_departure,
        longueur: filter_checkbox_length,
        denivellation: filter_checkbox_deniv,
        altitude: header_table_alt,
        percent_moyen: header_table_avgpercent,
        percent_maximal: header_table_maxpercent
      },
    sort: "denivellation", reverse: true
})
```


```{ojs}
//| output: true
(width > 400) ?
  html`
  <div class="main-container">
    <div id = "leafletmap" style="width: 40%;">${leafletmap}</div>
    <div class="column spacer" style="width: 2%;">
        <!-- Spacer column -->
    </div>
    <div style="width: 58%;">
      <div id="available-ascent">
      <div><i>${finding_ascent_label}</i></div>
      <br>
      ${table_selected}
      <br>
      </div>
    <div id="statsElement"><i>${no_ascent_label}</i></div>
    </div>
  </div>
  ` :
  html`
    <div id = "leafletmap" style="width: 100%;">${leafletmap}</div>
    <div style="width: 100%;">
      <div id="available-ascent">
      <div><i>${finding_ascent_label}</i></div>
      <br>
      ${table_selected}
      <br>
      </div>
    <div id="statsElement"><i>${no_ascent_label}</i></div>
    </div>
  `
```


```{ojs}
mutable selectlatlng = null
```

```{ojs}
function normalize(gj) {
    if (!gj || !gj.type) return null;
    var types = {
        Point: 'geometry',
        MultiPoint: 'geometry',
        LineString: 'geometry',
        MultiLineString: 'geometry',
        Polygon: 'geometry',
        MultiPolygon: 'geometry',
        GeometryCollection: 'geometry',
        Feature: 'feature',
        FeatureCollection: 'featurecollection'
    };
    var type = types[gj.type];
    if (!type) return null;

    if (type === 'geometry') {
        return {
            type: 'FeatureCollection',
            features: [{
                type: 'Feature',
                properties: {},
                geometry: gj
            }]
        };
    } else if (type === 'feature') {
        return {
            type: 'FeatureCollection',
            features: [gj]
        };
    } else if (type === 'featurecollection') {
        return gj;
    }
}
```


```{ojs}
function fetchAndNormalizeGeoJSON(id, baseUrl) {
    return fetch(`${baseUrl}/${id}.geojson`)
        .then(response => response.json())
        .then(normalize) // Assuming `normalize` function is available in the scope
        .catch(error => {
          console.error(`Failed to fetch or normalize GeoJSON for ID: ${id}`, error);
          return null;
        }) ;
}
```

```{ojs}
function mergeGeoJSONs(ids, baseUrl) {
    const promises = ids.map(id => fetchAndNormalizeGeoJSON(id, baseUrl));

    return Promise.all(promises)
        .then(normalizedGeoJSONs => {
            return normalizedGeoJSONs.reduce((output, geojson) => {
                if (geojson && geojson.features) {
                    output.features.push(...geojson.features);
                }
                return output;
            }, {
                type: 'FeatureCollection',
                features: []
            });
        });
}
```

```{ojs}
async function getCombinedGeoJSON(ids, baseUrl) {
  try {
    let combinedGeoJSON = await mergeGeoJSONs(ids, baseUrl);
    console.log('Combined GeoJSON:', combinedGeoJSON);
    // Handle the combined GeoJSON (e.g., display on map)
    return combinedGeoJSON; // This will be a GeoJSON object
  } catch (error) {
    console.error('An error occurred while merging GeoJSONs:', error);
    // Handle the error appropriately
  }
}
```

```{ojs}
function addGeoJSONToMap(geoJSON, map) {
  L.geoJSON(geoJSON, {
      style: function(feature) {
          // Define the style of the polyline here if needed
          return { color: feature.properties.stroke || 'blue', weight: 2 };
      },
      onEachFeature: function(feature, layer) {
          // If you want to do something with each feature like bind a popup
          if (feature.properties && feature.properties.name) {
              layer.bindPopup(feature.properties.name);
          }
      }
  }).addTo(map);
}
```


```{=html}
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.css" rel="stylesheet">
<link rel="stylesheet" href="https://raw.githubusercontent.com/lennardv2/Leaflet.awesome-markers/2.0/develop/dist/leaflet.awesome-markers.css">
```

```{ojs}
mutable foundfeatures = null ;
```

```{ojs}
function getPointsWithinCircle(centerCircle, sommets){

    var options = {steps: 64, units: 'kilometers'};
    var circle = turf.circle(
      centerCircle , radiusInner, options
    );
    // Perform spatial query with Turf.js using the drawn circle
    var pointsWithin = turf.pointsWithinPolygon(sommets, circle);

    return pointsWithin    
  }
```


```{ojs}
leafletmap = {

  // Create a container element for leaflet map
  let parent = DOM.element('div', { style: `width:${mapWidth}px;height:${mapHeight}px` });
  yield parent;
  var map = L.map(parent).setView([45.853459, 2.349312], 5);

  const baseUrl = 'https://minio.lab.sspcloud.fr/lgaliana/cyclisme/data/geojson/split';
  var radiustemp = radius ;

  // Add the layer control to the map
  let baseLayers = availableLayers(L, map) ;
  L.control.layers(baseLayers).addTo(map);


  var geocoder = L.geocoderBAN({
    collapsed: false, style: 'searchBar'
    }).addTo(map)

  geocoder.markGeocode = function(feature) {
    var latlng = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]]
    map.setView(latlng, 8)
    mutable selectlatlng = latlng;
    mutable foundfeatures = feature ;
  }

  if (selectlatlng != null){

    console.log(selectlatlng)

    // Center of the circle
    var foundpoint = createIcon(
      null, selectlatlng, "black"
    ).addTo(map);
    foundpoint.bindPopup(foundfeatures.properties.label).openPopup() ;
    // Circle
    var circle = L.circle(selectlatlng, { radius: radiusInner*1000 }).addTo(map);
    map.fitBounds(circle.getBounds())

    // Detect points within circle
    const pointsWithin = getPointsWithinCircle(selectlatlng.reverse(), sommets) ;
    mutable aroundClimb = pointsWithin

    // Add rot

    // Add summit markers
    var geojsonLayer = L.geoJson(
        pointsWithin, {
          onEachFeature: popEventSummit,
          pointToLayer: function(feature, coordinates) {
            return createIcon(feature, coordinates)        
        }
    }).addTo(map);


    // Add ascent routes tracks
    const ids = pointsWithin.features.map(d=> d.properties.id) ;
    getCombinedGeoJSON(ids, baseUrl)
    .then(combinedGeoJSON => {
        // Add each feature from the combined GeoJSON as a separate polyline
        combinedGeoJSON.features.forEach((feature) => {
            addGeoJSONToMap(feature, map);
        });
    })
    .catch(error => {
        console.error('An error occurred:', error);
    });

    }

  // Define a function that will be called for each feature in your GeoJSON layer
  function popEventSummit(feature, layer) {

      // Add mouseover event listener
      layer.on('mouseover', function() {
        const tooltipMessage = tooltipSummit(feature) ;
        layer.bindTooltip(
          tooltipMessage, {permanent: false, direction: "auto"}
          ).openTooltip();
      });

      // Create popup for ascent summit
      layer.bindPopup(
        popUpSummit(feature, lang)
      );

     layer.on({
       click: whenClicked, //callback functions
     });
      
      // Existing event listener for popup opens
      layer.on('popupopen', function() {
        const statsElement = document.getElementById('statsElement');
        const availableAscents = document.getElementById('available-ascent');        
        
        // Update the content of 'statsElement' with the desired statistics from 'feature.properties'
        statsElement.innerHTML = container_ascent(feature, lang, width) ;
        availableAscents.innerHTML = "" ;

        // Fetch route for selected ascent
        fetchAndDisplayAscentRoute(map, feature, 'red');
      });

  }

}
```



```{ojs}
mutable aroundClimb = null
```